generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * ----------------------------- Enums -----------------------------
 */

enum Role {
  ADMIN
  MANAGER
  EMPLOYEE
}

enum Channel {
  SMS
  WHATSAPP
  EMAIL
  TWITTER
  MESSENGER
}

enum ActivityType {
  LOGIN
  PROFILE_CHANGE
  OTHER
}

enum Direction {
  INBOUND
  OUTBOUND
}

enum TaskStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum NotificationType {
  WARNING
  PRAISE
  INVITE
  GENERIC
}

enum InviteStatus {
  PENDING
  ACCEPTED
  EXPIRED
}

/**
 * ----------------------------- Models -----------------------------
 */

model Organization {
  id        String   @id @default(cuid())
  name      String   @unique
  domain    String? // optional
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  users    User[]
  teams    Team[]
  contacts Contact[]
  invites  Invite[]
  threads  Thread[]
  activity ActivityLog[]

  // Opposite relation arrays for models that reference Organization
  tasks                Task[]
  performanceSnapshots PerformanceSnapshot[]
  notifications        Notification[]
  auditReports         AuditReport[]

  @@index([name])
}

/**
 * Core user/auth models
 * - email: unique at DB level (global uniqueness)
 * - organization: required â€” every user belongs to an organization
 * - role: ADMIN | MANAGER | EMPLOYEE
 */
model User {
  id             String       @id @default(cuid())
  name           String?
  email          String       @unique
  passwordHash   String?
  provider       String       @default("email") // "email" | "google" | "github" | ...
  providerId     String? // provider-specific id (not globally unique across providers)
  googleSub      String?      @unique
  emailVerified  Boolean      @default(false)
  phone          String?      @unique
  phoneVerified  Boolean      @default(false)
  isActive       Boolean      @default(false)
  role           Role         @default(EMPLOYEE)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @default(now()) @updatedAt

  profile     Profile?
  accounts    Account[]
  sessions    Session[]
  activityLog ActivityLog[]
  teamMember  TeamMember[]

  // Threads/messages authored by the user
  threadsCreated Thread[]  @relation("UserThreads")
  messagesSent   Message[] @relation("UserMessages")

  // scheduled messages created by the user
  scheduledMessage ScheduledMessage[]

  // Task relations (named to disambiguate)
  tasksAssignedTo Task[] @relation("AssignedTo")
  tasksCreatedBy  Task[] @relation("AssignedBy")

  invitesSent Invite[] @relation("InvitesSent")

  performanceSnapshots PerformanceSnapshot[]
  notifications        Notification[]

  // audit reports (created & received)
  auditReportsCreated  AuditReport[] @relation("ReportsCreated")
  auditReportsReceived AuditReport[] @relation("ReportsReceived")

  // Opposite relations for assignee/manager roles (explicit names)
  assignedThreads  Thread[]  @relation("UserAssignedThreads")
  assignedMessages Message[] @relation("UserAssignedMessages")
  managedTeams     Team[]    @relation("UserManagedTeams")

  @@index([organizationId])
}

/**
 * Profile holds additional user metadata.
 */
model Profile {
  id              String    @id @default(cuid())
  userId          String    @unique
  displayName     String?
  avatarUrl       String?
  bio             String?
  metadata        Json?
  phoneNumber     String?
  phoneVerified   Boolean   @default(false)
  phoneVerifiedAt DateTime?
  countryCode     String?
  timezone        String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @default(now()) @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

/**
 * Invite model for Managers / Employees
 * Consolidated and aligned so there is only one invite model in the schema.
 */
model Invite {
  id             String       @id @default(cuid())
  token          String       @unique
  email          String
  role           Role
  inviterId      String?
  inviter        User?        @relation("InvitesSent", fields: [inviterId], references: [id], onDelete: SetNull)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  teamId         String?
  team           Team?        @relation(fields: [teamId], references: [id], onDelete: SetNull)
  expiresAt      DateTime
  status         InviteStatus @default(PENDING)
  acceptedAt     DateTime?
  createdAt      DateTime     @default(now())

  @@index([organizationId, email])
}

/**
 * OTP stores (email & phone). Keep for auditing/rate-limiting.
 */
model EmailOtp {
  id        String   @id @default(cuid())
  email     String
  otp       String
  verified  Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([email])
}

model PhoneOtp {
  id        String   @id @default(cuid())
  phone     String
  otp       String
  used      Boolean  @default(false)
  attempts  Int      @default(0)
  createdAt DateTime @default(now())

  @@index([phone])
}

/**
 * Activity logs for auditing user actions
 * Added optional organization reference so Organization.activity has an opposite.
 */
model ActivityLog {
  id             String        @id @default(cuid())
  userId         String
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  type           ActivityType
  meta           Json?
  createdAt      DateTime      @default(now())

  @@index([userId, createdAt])
}

/**
 * NextAuth-compatible models (Account, Session, VerificationToken)
 */
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

/**
 * ----------------------------- Messaging / Contacts (org-scoped) -----------------------------
 */

model Contact {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  name           String?
  phone          String?
  email          String?
  metadata       Json?
  threads        Thread[]
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @default(now()) @updatedAt

  @@unique([organizationId, phone], map: "unique_org_phone")
  @@unique([organizationId, email], map: "unique_org_email")
  /// ensure contact uniqueness per organization where values exist
  @@index([organizationId])
}

/**
 * Thread (conversation) is org-scoped and linked to a Contact.
 */
model Thread {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  contactId      String
  contact        Contact      @relation(fields: [contactId], references: [id], onDelete: Cascade)
  creatorId      String?
  creator        User?        @relation("UserThreads", fields: [creatorId], references: [id], onDelete: SetNull)

  // assignee relation uses a named relation so Prisma can disambiguate
  assigneeId String? // user assigned to thread (employee/manager)
  assignee   User?   @relation("UserAssignedThreads", fields: [assigneeId], references: [id], onDelete: SetNull)

  teamId    String? // which team owns / is responsible for the thread
  team      Team?              @relation(fields: [teamId], references: [id], onDelete: SetNull)
  messages  Message[]
  scheduled ScheduledMessage[]
  status    String             @default("open")
  lastAt    DateTime           @updatedAt
  createdAt DateTime           @default(now())

  @@index([organizationId, contactId])
}

/**
 * Message: normalized incoming/outgoing messages for all channels.
 */
model Message {
  id       String @id @default(cuid())
  threadId String
  thread   Thread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  // sender: who created/sent the message (user)
  senderId String?
  sender   User?   @relation("UserMessages", fields: [senderId], references: [id], onDelete: SetNull)

  body       String
  channel    Channel
  externalId String? // provider message id
  direction  Direction

  // assignee: who handled / replied to this message (named relation)
  assigneeId String?
  assignee   User?   @relation("UserAssignedMessages", fields: [assigneeId], references: [id], onDelete: SetNull)

  metadata  Json?
  createdAt DateTime @default(now())

  @@index([threadId])
  @@index([externalId])
}

/**
 * Scheduled messages
 */
model ScheduledMessage {
  id        String   @id @default(cuid())
  threadId  String
  thread    Thread   @relation(fields: [threadId], references: [id], onDelete: Cascade)
  senderId  String?
  sender    User?    @relation(fields: [senderId], references: [id], onDelete: SetNull)
  body      String
  channel   Channel
  sendAt    DateTime
  status    String   @default("scheduled") // scheduled | sent | failed | cancelled
  metadata  Json?
  createdAt DateTime @default(now())

  @@index([sendAt])
}

/**
 * ----------------------------- Teams, Tasks, Performance -----------------------------
 */

model Team {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  name           String
  description    String?
  managerId      String? // primary manager for the team
  manager        User?        @relation("UserManagedTeams", fields: [managerId], references: [id], onDelete: SetNull)
  members        TeamMember[]
  threads        Thread[]
  invites        Invite[] // opposite for Invite.team

  // opposite for Task.team
  tasks Task[]

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@index([organizationId])
}

model TeamMember {
  id       String   @id @default(cuid())
  teamId   String
  team     Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  userId   String
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role     Role     @default(EMPLOYEE)
  joinedAt DateTime @default(now())

  @@unique([teamId, userId])
}

/**
 * Task assigned to an employee by a manager (used for performance)
 */
model Task {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  title          String
  description    String?
  assignedToId   String?      @map("assigned_to_id")
  assignedTo     User?        @relation("AssignedTo", fields: [assignedToId], references: [id], onDelete: SetNull)
  assignedById   String?      @map("assigned_by_id")
  assignedBy     User?        @relation("AssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)
  teamId         String?
  team           Team?        @relation(fields: [teamId], references: [id], onDelete: SetNull)
  status         TaskStatus   @default(OPEN)
  dueDate        DateTime?
  completedAt    DateTime?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @default(now()) @updatedAt

  @@index([organizationId, assignedToId])
}

/**
 * Snapshot of performance metrics for a user over a sliding window (e.g., 60 days).
 */
model PerformanceSnapshot {
  id             String       @id @default(cuid())
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  startAt        DateTime
  endAt          DateTime
  score          Float // 0-100
  metrics        Json // detailed metrics
  createdAt      DateTime     @default(now())

  @@index([userId, startAt, endAt])
}

/**
 * ----------------------------- Notifications & Audit Reports -----------------------------
 */

model Notification {
  id             String           @id @default(cuid())
  userId         String
  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  organizationId String
  organization   Organization     @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  type           NotificationType
  title          String
  body           String
  meta           Json?
  read           Boolean          @default(false)
  createdAt      DateTime         @default(now())

  @@index([userId, organizationId, type])
}

/**
 * Audit reports (managers create reports for employees; admins view all)
 */
model AuditReport {
  id             String       @id @default(cuid())
  title          String
  body           String
  createdById    String?
  createdBy      User?        @relation("ReportsCreated", fields: [createdById], references: [id], onDelete: SetNull)
  recipientId    String? // user report is about (employee)
  recipient      User?        @relation("ReportsReceived", fields: [recipientId], references: [id], onDelete: SetNull)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  metrics        Json?
  createdAt      DateTime     @default(now())

  @@index([organizationId, createdById])
}

{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["// lib/prisma.ts\r\nimport { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line\r\n  var __prisma__: PrismaClient | undefined;\r\n}\r\nexport const prisma =\r\n  global.__prisma__ ??\r\n  new PrismaClient({\r\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"warn\", \"error\"] : [\"error\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.__prisma__ = prisma;\r\n"],"names":[],"mappings":"AAAA,gBAAgB;;;;;AAChB;;AAMO,MAAM,SACX,OAAO,UAAU,IACjB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAQ;KAAQ,GAAG;AAC7E;AAEF,wCAA2C,OAAO,UAAU,GAAG","debugId":null}},
    {"offset": {"line": 95, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/jwt.ts"],"sourcesContent":["// src/lib/jwt.ts\r\nimport jwt, { JwtPayload } from \"jsonwebtoken\";\r\n\r\nconst SECRET = process.env.JWT_SECRET;\r\nif (!SECRET) {\r\n  if (process.env.NODE_ENV === \"production\") {\r\n    throw new Error(\"JWT_SECRET environment variable must be set in production!\");\r\n  } else {\r\n    console.warn(\"[JWT] Using fallback secret for development\");\r\n  }\r\n}\r\n\r\n/**\r\n * üîê Create a short-lived temp token (email/phone verification)\r\n */\r\nexport function signTemp(payload: Record<string, any>, expiresIn: string = \"15m\"): string {\r\n  const safePayload = { ...payload };\r\n  delete safePayload.exp;\r\n  return jwt.sign(safePayload, SECRET!, { expiresIn });\r\n}\r\n\r\n/**\r\n * ‚úÖ Verify short-lived temp tokens\r\n * Returns payload object or null if invalid/expired\r\n */\r\nexport function verifyTemp(token: string): Record<string, any> | null {\r\n  try {\r\n    return jwt.verify(token, SECRET!) as Record<string, any>;\r\n  } catch (err) {\r\n    console.warn(\"[JWT] verifyTemp failed:\", (err as Error).message);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * üíæ Create a long-lived session token for logged-in users\r\n */\r\nexport function signSession(payload: Record<string, any>, expiresIn: string = \"7d\"): string {\r\n  const safePayload = { ...payload };\r\n  delete safePayload.exp;\r\n  return jwt.sign(safePayload, SECRET!, { expiresIn });\r\n}\r\n\r\n/**\r\n * üîé Verify a session token\r\n * Returns payload object or null if invalid/expired\r\n */\r\nexport function verifySession(token: string): Record<string, any> | null {\r\n  try {\r\n    return jwt.verify(token, SECRET!) as Record<string, any>;\r\n  } catch (err) {\r\n    console.warn(\"[JWT] verifySession failed:\", (err as Error).message);\r\n    return null;\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,iBAAiB;;;;;;;;;;;AACjB;;AAEA,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU;AACrC,IAAI,CAAC,QAAQ;IACX;;SAEO;QACL,QAAQ,IAAI,CAAC;IACf;AACF;AAKO,SAAS,SAAS,OAA4B,EAAE,YAAoB,KAAK;IAC9E,MAAM,cAAc;QAAE,GAAG,OAAO;IAAC;IACjC,OAAO,YAAY,GAAG;IACtB,OAAO,kJAAG,CAAC,IAAI,CAAC,aAAa,QAAS;QAAE;IAAU;AACpD;AAMO,SAAS,WAAW,KAAa;IACtC,IAAI;QACF,OAAO,kJAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAO,KAAK;QACZ,QAAQ,IAAI,CAAC,4BAA4B,AAAC,IAAc,OAAO;QAC/D,OAAO;IACT;AACF;AAKO,SAAS,YAAY,OAA4B,EAAE,YAAoB,IAAI;IAChF,MAAM,cAAc;QAAE,GAAG,OAAO;IAAC;IACjC,OAAO,YAAY,GAAG;IACtB,OAAO,kJAAG,CAAC,IAAI,CAAC,aAAa,QAAS;QAAE;IAAU;AACpD;AAMO,SAAS,cAAc,KAAa;IACzC,IAAI;QACF,OAAO,kJAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAO,KAAK;QACZ,QAAQ,IAAI,CAAC,+BAA+B,AAAC,IAAc,OAAO;QAClE,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 160, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/app/api/auth/signup/finalize/route.ts"],"sourcesContent":["// app/api/auth/signup/finalize/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { verifyTemp, signSession } from \"@/lib/jwt\";\r\nimport bcrypt from \"bcrypt\";\r\nimport { Prisma } from \"@prisma/client\";\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const body = await req.json();\r\n    const { name, organizationName, password, tempToken, email } = body;\r\n\r\n    if (!name || !organizationName || !password || !tempToken) {\r\n      return NextResponse.json(\r\n        { ok: false, error: \"missing_fields\" },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Verify temp token\r\n    let decoded: any;\r\n    try {\r\n      decoded = verifyTemp(tempToken);\r\n    } catch (err) {\r\n      console.error(\"[verifyTemp failed]\", err);\r\n      return NextResponse.json(\r\n        { ok: false, error: \"invalid_or_expired_temp_token\" },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // token must contain phone and indicate phone is verified\r\n    if (!decoded?.phone || !decoded?.phoneVerified) {\r\n      return NextResponse.json(\r\n        { ok: false, error: \"phone_not_verified\" },\r\n        { status: 403 }\r\n      );\r\n    }\r\n\r\n    const phone = decoded.phone as string;\r\n\r\n    // Pick email from request or from token\r\n    const rawEmail = (email ?? decoded?.email ?? null) as string | null;\r\n    if (!rawEmail) {\r\n      return NextResponse.json(\r\n        { ok: false, error: \"email_required\" },\r\n        { status: 400 }\r\n      );\r\n    }\r\n    const emailToSave = rawEmail.trim().toLowerCase();\r\n\r\n    // Pre-checks (helpful early failures + better error messages)\r\n    const existingByPhone = await prisma.user.findFirst({ where: { phone } });\r\n    if (existingByPhone) {\r\n      return NextResponse.json(\r\n        { ok: false, error: \"account_already_exists_phone\" },\r\n        { status: 409 }\r\n      );\r\n    }\r\n    const existingByEmail = await prisma.user.findUnique({\r\n      where: { email: emailToSave },\r\n    });\r\n    if (existingByEmail) {\r\n      return NextResponse.json(\r\n        { ok: false, error: \"account_already_exists_email\" },\r\n        { status: 409 }\r\n      );\r\n    }\r\n\r\n    // Hash password\r\n    const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n    // Canonicalize organization name (trim)\r\n    const orgName = organizationName.trim();\r\n\r\n    // Use a transaction to create organization + admin atomically,\r\n    // and to re-check existence inside the transaction to avoid races.\r\n    try {\r\n      const result = await prisma.$transaction(async (tx) => {\r\n        // 1) Re-check user/email/phone inside transaction to avoid TOCTOU\r\n        const userByEmail = await tx.user.findUnique({\r\n          where: { email: emailToSave },\r\n        });\r\n        if (userByEmail) {\r\n          throw new Error(\"EMAIL_TAKEN\");\r\n        }\r\n        const userByPhone = await tx.user.findFirst({\r\n          where: { phone },\r\n        });\r\n        if (userByPhone) {\r\n          throw new Error(\"PHONE_TAKEN\");\r\n        }\r\n\r\n        // 2) Check organization existence.\r\n        // Intention: when a user is creating an org via signup, they must create a new org.\r\n        // If an org with that name already exists, reject the signup (prevent duplicate org names).\r\n        const existingOrg = await tx.organization.findFirst({\r\n          where: { name: orgName },\r\n        });\r\n        if (existingOrg) {\r\n          // Organization already exists -> block creation.\r\n          throw new Error(\"ORG_EXISTS\");\r\n        }\r\n\r\n        // 3) Create organization\r\n        const organization = await tx.organization.create({\r\n          data: {\r\n            name: orgName,\r\n          },\r\n        });\r\n\r\n        // 4) Compute verification flags\r\n        const phoneVerified = true; // required by temp token\r\n        const emailVerified = Boolean(decoded?.emailVerified) || false;\r\n        const isActive = phoneVerified && emailVerified;\r\n\r\n        // 5) Create user (admin) connected to organization\r\n        const user = await tx.user.create({\r\n          data: {\r\n            name,\r\n            phone,\r\n            email: emailToSave,\r\n            passwordHash: hashedPassword,\r\n            role: \"ADMIN\",\r\n            phoneVerified,\r\n            emailVerified,\r\n            isActive,\r\n            organization: {\r\n              connect: { id: organization.id },\r\n            },\r\n            profile: {\r\n              create: { displayName: name, phoneNumber: phone },\r\n            },\r\n          },\r\n          include: {\r\n            organization: true,\r\n            profile: true,\r\n          },\r\n        });\r\n\r\n        return { user, organization };\r\n      });\r\n\r\n      const { user, organization } = result;\r\n\r\n      // Sign session only if fully active (both phone + email verified)\r\n      let sessionToken: string | null = null;\r\n      if (user.isActive) {\r\n        sessionToken = signSession({\r\n          id: user.id,\r\n          role: user.role,\r\n          phone: user.phone,\r\n          org: user.organization.id,\r\n        });\r\n      }\r\n\r\n      return NextResponse.json(\r\n        {\r\n          ok: true,\r\n          activated: user.isActive,\r\n          user: {\r\n            id: user.id,\r\n            name: user.name,\r\n            phone: user.phone,\r\n            role: user.role,\r\n            organization: organization.name,\r\n            emailVerified: user.emailVerified,\r\n            phoneVerified: user.phoneVerified,\r\n          },\r\n          token: sessionToken,\r\n        },\r\n        { status: 201 }\r\n      );\r\n    } catch (txErr: any) {\r\n      // Known flow errors thrown above\r\n      if (txErr?.message === \"ORG_EXISTS\") {\r\n        return NextResponse.json(\r\n          { ok: false, error: \"organization_already_exists\" },\r\n          { status: 409 }\r\n        );\r\n      }\r\n      if (txErr?.message === \"EMAIL_TAKEN\") {\r\n        return NextResponse.json(\r\n          { ok: false, error: \"account_already_exists_email\" },\r\n          { status: 409 }\r\n        );\r\n      }\r\n      if (txErr?.message === \"PHONE_TAKEN\") {\r\n        return NextResponse.json(\r\n          { ok: false, error: \"account_already_exists_phone\" },\r\n          { status: 409 }\r\n        );\r\n      }\r\n\r\n      // Prisma unique violation fallback (in case DB has unique constraint names)\r\n      if (txErr instanceof Prisma.PrismaClientKnownRequestError && txErr.code === \"P2002\") {\r\n        const target = (txErr.meta as any)?.target;\r\n        if (Array.isArray(target) && target.includes(\"email\")) {\r\n          return NextResponse.json(\r\n            { ok: false, error: \"account_already_exists_email\" },\r\n            { status: 409 }\r\n          );\r\n        }\r\n        if (Array.isArray(target) && (target.includes(\"name\") || target.includes(\"organization_name\"))) {\r\n          return NextResponse.json(\r\n            { ok: false, error: \"organization_already_exists\" },\r\n            { status: 409 }\r\n          );\r\n        }\r\n      }\r\n\r\n      console.error(\"[Signup transaction error]\", txErr);\r\n      return NextResponse.json(\r\n        { ok: false, error: txErr.message || \"internal_server_error\" },\r\n        { status: 500 }\r\n      );\r\n    }\r\n  } catch (err: any) {\r\n    console.error(\"[Signup Finalize Error]\", err);\r\n    return NextResponse.json(\r\n      { ok: false, error: err.message || \"internal_server_error\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}
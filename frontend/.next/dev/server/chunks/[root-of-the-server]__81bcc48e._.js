module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/@prisma/client [external] (@prisma/client, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("@prisma/client", () => require("@prisma/client"));

module.exports = mod;
}),
"[externals]/node:http [external] (node:http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:http", () => require("node:http"));

module.exports = mod;
}),
"[externals]/node:https [external] (node:https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:https", () => require("node:https"));

module.exports = mod;
}),
"[externals]/node:zlib [external] (node:zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:zlib", () => require("node:zlib"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/node:buffer [external] (node:buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:buffer", () => require("node:buffer"));

module.exports = mod;
}),
"[externals]/node:util [external] (node:util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:util", () => require("node:util"));

module.exports = mod;
}),
"[externals]/node:process [external] (node:process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:process", () => require("node:process"));

module.exports = mod;
}),
"[externals]/node:stream/web [external] (node:stream/web, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream/web", () => require("node:stream/web"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/node:url [external] (node:url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:url", () => require("node:url"));

module.exports = mod;
}),
"[externals]/node:net [external] (node:net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:net", () => require("node:net"));

module.exports = mod;
}),
"[externals]/node:fs [external] (node:fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs", () => require("node:fs"));

module.exports = mod;
}),
"[externals]/node:path [external] (node:path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:path", () => require("node:path"));

module.exports = mod;
}),
"[externals]/worker_threads [external] (worker_threads, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("worker_threads", () => require("worker_threads"));

module.exports = mod;
}),
"[project]/src/lib/socket.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/lib/socket.ts
// Small helper to call the socket server's /emit endpoint from backend code.
// Usage:
//   import { emitToRooms } from "@/lib/socket";
//   await emitToRooms({ event: "chat:created", rooms: ["user:123","org:abc"], payload: {...} });
__turbopack_context__.s([
    "emitToRooms",
    ()=>emitToRooms
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/index.js [app-route] (ecmascript) <locals>");
;
const SOCKET_SERVER_URL = process.env.SOCKET_SERVER_URL || process.env.NEXT_PUBLIC_SOCKET_URL || "http://localhost:4001";
const SOCKET_SERVER_KEY = process.env.SOCKET_SERVER_KEY || "";
async function emitToRooms({ event, payload = {}, rooms, excludeSocketId, timeoutMs = 2000 }) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    if (!SOCKET_SERVER_KEY) {
        // still allow if no key supplied (not recommended for prod)
        console.warn("socket: no SOCKET_SERVER_KEY configured — /emit endpoint not protected");
    }
    const url = new URL("/emit", SOCKET_SERVER_URL).toString();
    const body = {
        key: SOCKET_SERVER_KEY,
        rooms,
        event,
        payload,
        excludeSocketId
    };
    try {
        const controller = new AbortController();
        const id = setTimeout(()=>controller.abort(), timeoutMs);
        const resp = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"])(url, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(body),
            signal: controller.signal
        });
        clearTimeout(id);
        if (!resp.ok) {
            const text = await resp.text().catch(()=>"");
            return {
                ok: false,
                status: resp.status,
                body: text
            };
        }
        const json = await resp.json().catch(()=>({}));
        return {
            ok: true,
            result: json
        };
    } catch (err) {
        return {
            ok: false,
            error: String(err?.message ?? err)
        };
    }
}
}),
"[project]/src/lib/socketAdapter.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/lib/socketAdapter.ts
// Adapter to forward legacy `global.io` / `global._io` / `global.socketServer`
// calls to the standalone socket server via the /emit HTTP endpoint.
__turbopack_context__.s([
    "socketAdapter",
    ()=>adapter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$socket$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/socket.ts [app-route] (ecmascript)");
;
function makeRoomEmitter(room) {
    return {
        emit: (event, payload)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$socket$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["emitToRooms"])({
                event,
                payload,
                rooms: room
            });
        },
        // allow io.to(room).except(socketId).emit(...) pattern
        except: (socketId)=>({
                emit: (event, payload)=>{
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$socket$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["emitToRooms"])({
                        event,
                        payload,
                        rooms: room,
                        excludeSocketId: socketId
                    });
                }
            })
    };
}
// Single shared adapter instance
const adapter = {
    /**
   * io.emit("event", payload)
   *  -> broadcast globally
   */ emit: (event, payload)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$socket$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["emitToRooms"])({
            event,
            payload
        });
    },
    /**
   * io.to("room").emit("event", payload)
   *  -> broadcast to specific room(s)
   */ to: (room)=>makeRoomEmitter(room)
};
function attachGlobals() {
    if (global.__socketAdapterInitialized) return;
    global.__socketAdapterInitialized = true;
    // These are the names used in your API code:
    // (global as any).io || (global as any)._io || (global as any).socketServer
    const g = global;
    if (!g.io) g.io = adapter;
    if (!g._io) g._io = adapter;
    if (!g.socketServer) g.socketServer = adapter;
}
// Run immediately on import (server-only)
attachGlobals();
;
}),
"[project]/src/lib/prisma.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// lib/prisma.ts
__turbopack_context__.s([
    "prisma",
    ()=>prisma
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/@prisma/client [external] (@prisma/client, cjs)");
// near the top, before exports
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$socketAdapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/socketAdapter.ts [app-route] (ecmascript)");
;
;
const prisma = global.__prisma__ ?? new __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["PrismaClient"]({
    log: ("TURBOPACK compile-time truthy", 1) ? [
        "query",
        "warn",
        "error"
    ] : "TURBOPACK unreachable"
});
if ("TURBOPACK compile-time truthy", 1) global.__prisma__ = prisma;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[project]/src/lib/jwt.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/lib/jwt.ts
__turbopack_context__.s([
    "signSession",
    ()=>signSession,
    "signTemp",
    ()=>signTemp,
    "verifySession",
    ()=>verifySession,
    "verifyTemp",
    ()=>verifyTemp
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jsonwebtoken/index.js [app-route] (ecmascript)");
;
const SECRET = process.env.JWT_SECRET;
if (!SECRET) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        console.warn("[JWT] Using fallback secret for development");
    }
}
function signTemp(payload, expiresIn = "15m") {
    const safePayload = {
        ...payload
    };
    delete safePayload.exp;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].sign(safePayload, SECRET, {
        expiresIn
    });
}
function verifyTemp(token) {
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].verify(token, SECRET);
    } catch (err) {
        console.warn("[JWT] verifyTemp failed:", err.message);
        return null;
    }
}
function signSession(payload, expiresIn = "7d") {
    const safePayload = {
        ...payload
    };
    delete safePayload.exp;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].sign(safePayload, SECRET, {
        expiresIn
    });
}
function verifySession(token) {
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].verify(token, SECRET);
    } catch (err) {
        console.warn("[JWT] verifySession failed:", err.message);
        return null;
    }
}
}),
"[project]/src/lib/auth.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/lib/auth.ts
__turbopack_context__.s([
    "getSessionUser",
    ()=>getSessionUser
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/prisma.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$jwt$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/jwt.ts [app-route] (ecmascript)");
;
;
async function getSessionUser(req) {
    try {
        // 1️⃣ Prefer Authorization header: "Bearer <token>"
        let token = null;
        const authHeader = req.headers.get("authorization");
        if (authHeader?.startsWith("Bearer ")) {
            token = authHeader.slice("Bearer ".length).trim();
        }
        // 2️⃣ Fallback to cookies
        if (!token) {
            const cookieHeader = req.headers.get("cookie") || "";
            const cookies = Object.fromEntries(cookieHeader.split(";").map((c)=>c.trim().split("=")).map(([k, v])=>[
                    decodeURIComponent(k),
                    decodeURIComponent(v)
                ]));
            token = cookies["session"] || cookies["token"] || null;
        }
        if (!token) return null;
        // 3️⃣ Verify token safely
        const payload = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$jwt$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifySession"])(token);
        if (!payload?.id) return null;
        // 4️⃣ Fetch user from DB
        const user = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].user.findUnique({
            where: {
                id: payload.id
            }
        });
        if (!user) return null;
        return {
            id: user.id,
            email: user.email ?? null,
            role: user.role,
            organizationId: user.organizationId
        };
    } catch (err) {
        console.warn("[getSessionUser] error:", err?.message || err);
        return null;
    }
}
}),
"[project]/src/app/api/chats/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/app/api/chats/route.ts
__turbopack_context__.s([
    "GET",
    ()=>GET,
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/prisma.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/auth.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/headers.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jsonwebtoken/index.js [app-route] (ecmascript)");
;
;
;
;
;
const JWT_SECRET = process.env.JWT_SECRET || "";
/* -------------------------------------------------------
   Helpers
------------------------------------------------------- */ async function safeJson(req) {
    try {
        return await req.json();
    } catch  {
        return {};
    }
}
/**
 * Resolve logged-in user from:
 * 1. next-auth helper
 * 2. Authorization header
 * 3. Session cookie
 */ async function resolveSessionUser(req) {
    // #1 next-auth
    try {
        const u = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getSessionUser"])(req);
        if (u?.id) return u;
    } catch  {}
    // #2 bearer
    try {
        const auth = req.headers.get("authorization") ?? req.headers.get("Authorization");
        if (auth?.toLowerCase().startsWith("bearer ")) {
            const token = auth.slice(7).trim();
            if (token && JWT_SECRET) {
                const payload = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].verify(token, JWT_SECRET);
                if (payload?.id) return payload;
            }
        }
    } catch  {}
    // #3 cookie
    try {
        const store = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
        const token = store.get("session")?.value;
        if (token && JWT_SECRET) {
            const payload = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].verify(token, JWT_SECRET);
            if (payload?.id) return payload;
        }
    } catch  {}
    return null;
}
/**
 * Authorize that user can access a team.
 * ADMIN → always pass
 * Manager or Member of team → pass
 */ async function authorizeTeamAccess(userId, userRole, teamId) {
    if (userRole === "ADMIN") return true;
    const team = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].team.findUnique({
        where: {
            id: teamId
        },
        select: {
            managerId: true
        }
    });
    if (!team) return false;
    // Is manager?
    if (team.managerId === userId) return true;
    // Is team member?
    const member = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].teamMember.findFirst({
        where: {
            teamId,
            userId
        },
        select: {
            id: true
        }
    });
    return !!member;
}
/**
 * Normalize a chat for frontend use
 * Hides admin ChatMember rows when chat.type is TEAM so admin does not appear in the member list.
 */ function normalizeChat(chat) {
    const isTeam = String(chat.type).toUpperCase() === "TEAM";
    return {
        id: chat.id,
        name: chat.name ?? (chat.team ? `Team: ${chat.team.name}` : "Chat"),
        type: chat.type,
        teamId: chat.teamId ?? null,
        createdBy: chat.createdBy ? {
            id: chat.createdBy.id,
            name: chat.createdBy.name
        } : null,
        members: (chat.members ?? []).filter((m)=>{
            // For team chats, do not expose ChatMember rows with role ADMIN (these are implicit admin access)
            if (isTeam && String(m.role).toUpperCase() === "ADMIN") return false;
            return !!(m.user && m.user.id);
        }).map((m)=>({
                id: m.user.id,
                name: m.user.name,
                email: m.user.email,
                role: m.role
            })) ?? [],
        lastMessageAt: chat.lastMessageAt?.toISOString?.() ?? null,
        createdAt: chat.createdAt?.toISOString?.() ?? null
    };
}
async function GET(req) {
    try {
        const session = await resolveSessionUser(req);
        if (!session) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                ok: false,
                error: "Unauthorized",
                chats: []
            }, {
                status: 401
            });
        }
        const userId = String(session.id);
        const userRole = session.role ?? null;
        const orgId = session.organizationId ?? null;
        const url = new URL(req.url);
        const teamId = url.searchParams.get("teamId");
        /* ----------------------------------------------
       TEAM CHAT MODE
    ---------------------------------------------- */ if (teamId) {
            const chat = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chat.findFirst({
                where: {
                    teamId
                },
                include: {
                    members: {
                        include: {
                            user: {
                                select: {
                                    id: true,
                                    name: true,
                                    email: true
                                }
                            }
                        }
                    },
                    team: {
                        select: {
                            id: true,
                            name: true
                        }
                    },
                    createdBy: {
                        select: {
                            id: true,
                            name: true
                        }
                    }
                }
            });
            // If not found, return null
            if (!chat) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    ok: true,
                    chat: null
                }, {
                    status: 200
                });
            }
            // Authorization: admins can view; others must be team members or manager
            const allowed = userRole === "ADMIN" || await authorizeTeamAccess(userId, userRole, teamId);
            if (!allowed) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    ok: false,
                    error: "Forbidden",
                    chat: null
                }, {
                    status: 403
                });
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                ok: true,
                chat: normalizeChat(chat)
            }, {
                status: 200
            });
        }
        /* ----------------------------------------------
       ALL CHATS FOR THIS USER
    ---------------------------------------------- */ if (userRole === "ADMIN") {
            // Admin: return all TEAM chats in org + any DIRECT/PRIVATE chats where admin is a member
            if (!orgId) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    ok: true,
                    chats: []
                }, {
                    status: 200
                });
            }
            // fetch team chats in org
            const teamChats = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chat.findMany({
                where: {
                    organizationId: orgId,
                    type: "TEAM"
                },
                include: {
                    members: {
                        include: {
                            user: {
                                select: {
                                    id: true,
                                    name: true,
                                    email: true
                                }
                            }
                        }
                    },
                    team: {
                        select: {
                            id: true,
                            name: true
                        }
                    },
                    createdBy: {
                        select: {
                            id: true,
                            name: true
                        }
                    }
                },
                orderBy: {
                    lastMessageAt: "desc"
                }
            });
            // fetch direct/private chats where admin is a member
            const directMembership = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chatMember.findMany({
                where: {
                    userId
                },
                select: {
                    chatId: true
                }
            });
            const directChatIds = directMembership.map((m)=>m.chatId);
            const directChats = directChatIds.length > 0 ? await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chat.findMany({
                where: {
                    id: {
                        in: directChatIds
                    }
                },
                include: {
                    members: {
                        include: {
                            user: {
                                select: {
                                    id: true,
                                    name: true,
                                    email: true
                                }
                            }
                        }
                    },
                    team: {
                        select: {
                            id: true,
                            name: true
                        }
                    },
                    createdBy: {
                        select: {
                            id: true,
                            name: true
                        }
                    }
                },
                orderBy: {
                    lastMessageAt: "desc"
                }
            }) : [];
            // merge and normalize (teamChats first)
            const merged = [
                ...teamChats,
                ...directChats
            ].map(normalizeChat);
            // dedupe by id (teamChats + direct could overlap in edge cases)
            const byId = new Map();
            for (const c of merged)byId.set(c.id, c);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                ok: true,
                chats: Array.from(byId.values())
            }, {
                status: 200
            });
        } else {
            // Non-admin: list chats where the user is a ChatMember
            const membership = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chatMember.findMany({
                where: {
                    userId
                },
                select: {
                    chatId: true
                }
            });
            if (membership.length === 0) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    ok: true,
                    chats: []
                }, {
                    status: 200
                });
            }
            const chatIds = membership.map((m)=>m.chatId);
            const chats = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chat.findMany({
                where: {
                    id: {
                        in: chatIds
                    }
                },
                include: {
                    members: {
                        include: {
                            user: {
                                select: {
                                    id: true,
                                    name: true,
                                    email: true
                                }
                            }
                        }
                    },
                    team: {
                        select: {
                            id: true,
                            name: true
                        }
                    },
                    createdBy: {
                        select: {
                            id: true,
                            name: true
                        }
                    }
                },
                orderBy: {
                    lastMessageAt: "desc"
                }
            });
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                ok: true,
                chats: chats.map(normalizeChat)
            }, {
                status: 200
            });
        }
    } catch (err) {
        console.error("GET /api/chats error:", err);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: false,
            error: "Internal Server Error"
        }, {
            status: 500
        });
    }
}
/* -------------------------------------------------------
   POST /api/chats
   Creates a chat (team group chat or direct chat)
   Body:
     {
       name?: string,
       teamId?: string,
       memberIds?: string[]   // other users (not including the requester) for a direct chat
     }
------------------------------------------------------- */ function mapUserRoleToChatRole(userRole) {
    if (userRole === "MANAGER") return "MANAGER";
    return "MEMBER";
}
async function POST(req) {
    try {
        const session = await resolveSessionUser(req);
        if (!session) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                ok: false,
                error: "Unauthorized",
                chat: null
            }, {
                status: 401
            });
        }
        const userId = String(session.id);
        const userRole = session.role ?? null;
        const orgId = session.organizationId ?? null;
        const body = await safeJson(req);
        const name = typeof body.name === "string" ? body.name.trim() : undefined;
        const teamId = typeof body.teamId === "string" ? body.teamId.trim() : undefined;
        let memberIds = Array.isArray(body.memberIds) ? body.memberIds.filter((x)=>typeof x === "string") : [];
        /* ----------------------------------------------
       TEAM CHAT
    ---------------------------------------------- */ if (teamId) {
            // check team exists
            const team = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].team.findUnique({
                where: {
                    id: teamId
                },
                select: {
                    id: true,
                    organizationId: true
                }
            });
            if (!team) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    ok: false,
                    error: "Team not found"
                }, {
                    status: 404
                });
            }
            // authorize
            const allowed = await authorizeTeamAccess(userId, userRole, teamId);
            if (!allowed) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    ok: false,
                    error: "Forbidden"
                }, {
                    status: 403
                });
            }
            // If chat exists, return it
            const existingTeamChat = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chat.findFirst({
                where: {
                    teamId
                },
                include: {
                    members: {
                        include: {
                            user: {
                                select: {
                                    id: true,
                                    name: true,
                                    email: true
                                }
                            }
                        }
                    },
                    team: {
                        select: {
                            id: true,
                            name: true
                        }
                    },
                    createdBy: {
                        select: {
                            id: true,
                            name: true
                        }
                    }
                }
            });
            if (existingTeamChat) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    ok: true,
                    created: false,
                    chat: normalizeChat(existingTeamChat)
                }, {
                    status: 200
                });
            }
            // Get all team members (user ids) and include requester
            const teamMembers = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].teamMember.findMany({
                where: {
                    teamId
                },
                select: {
                    userId: true
                }
            });
            const toAdd = Array.from(new Set([
                ...teamMembers.map((m)=>m.userId || ""),
                userId
            ].filter(Boolean)));
            // Remove org admins from membership list — admins have implicit access and should not be ChatMembers on team chats
            const users = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].user.findMany({
                where: {
                    id: {
                        in: toAdd
                    }
                },
                select: {
                    id: true,
                    role: true
                }
            });
            const filtered = users.filter((u)=>String(u.role).toUpperCase() !== "ADMIN");
            // create chat and chat members
            const chat = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chat.create({
                data: {
                    name: name ?? null,
                    type: "TEAM",
                    organization: orgId ? {
                        connect: {
                            id: orgId
                        }
                    } : undefined,
                    team: {
                        connect: {
                            id: teamId
                        }
                    },
                    createdBy: {
                        connect: {
                            id: userId
                        }
                    },
                    members: {
                        create: filtered.map((u)=>({
                                user: {
                                    connect: {
                                        id: u.id
                                    }
                                },
                                role: mapUserRoleToChatRole(u.role)
                            }))
                    }
                },
                include: {
                    members: {
                        include: {
                            user: {
                                select: {
                                    id: true,
                                    name: true,
                                    email: true
                                }
                            }
                        }
                    },
                    team: {
                        select: {
                            id: true,
                            name: true
                        }
                    },
                    createdBy: {
                        select: {
                            id: true,
                            name: true
                        }
                    }
                }
            });
            // emit chat:created to members & org room (best-effort)
            (async ()=>{
                try {
                    const io = /*TURBOPACK member replacement*/ __turbopack_context__.g.io || /*TURBOPACK member replacement*/ __turbopack_context__.g._io || /*TURBOPACK member replacement*/ __turbopack_context__.g.socketServer;
                    const payload = {
                        chat: {
                            id: chat.id,
                            name: chat.name,
                            teamId: teamId
                        },
                        teamId,
                        organizationId: orgId
                    };
                    if (io && typeof io.to === "function") {
                        for (const m of filtered){
                            io.to(`user:${m.id}`).emit("chat:created", payload);
                        }
                        io.to(`org:${orgId}`).emit("chat:created", payload);
                    } else if (io && typeof io.emit === "function") {
                        io.emit("chat:created", payload);
                    }
                } catch (e) {
                    console.warn("[api/chats] emit chat:created failed:", e);
                }
            })();
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                ok: true,
                created: true,
                chat: normalizeChat(chat)
            }, {
                status: 201
            });
        }
        /* ----------------------------------------------
       DIRECT / PRIVATE CHAT
       Enforce ACL rules:
         - ADMIN: can DM MANAGER or ADMIN; cannot DM EMPLOYEE privately
         - MANAGER: can DM ADMIN, other MANAGERs; can DM EMPLOYEE only if employee is in manager's team
         - EMPLOYEE: can DM only team members and their manager
    ---------------------------------------------- */ // dedupe and include requester
        const uniqueMemberIds = Array.from(new Set([
            ...memberIds,
            userId
        ]));
        // must have at least one other user to chat with
        if (uniqueMemberIds.length < 2) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                ok: false,
                error: "At least one other member required"
            }, {
                status: 400
            });
        }
        // Load users for ACL checks
        const otherIds = uniqueMemberIds.filter((id)=>id !== userId);
        const otherUsers = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].user.findMany({
            where: {
                id: {
                    in: otherIds
                }
            },
            select: {
                id: true,
                role: true,
                organizationId: true
            }
        });
        // ensure all targets exist and belong to same org
        const foundIds = new Set(otherUsers.map((u)=>u.id));
        for (const tid of otherIds){
            if (!foundIds.has(tid)) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    ok: false,
                    error: `User not found: ${tid}`
                }, {
                    status: 404
                });
            }
        }
        // ensure same organization
        for (const u of otherUsers){
            if (orgId && u.organizationId !== orgId) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    ok: false,
                    error: "All chat participants must belong to your organization"
                }, {
                    status: 400
                });
            }
        }
        // ACL enforcement per target
        for (const target of otherUsers){
            const tgtRole = String(target.role).toUpperCase();
            if (userRole === "ADMIN") {
                // admin can talk to MANAGER/ADMIN; cannot privately message EMPLOYEE
                if (tgtRole === "EMPLOYEE") {
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                        ok: false,
                        error: "Admin cannot privately message an employee"
                    }, {
                        status: 403
                    });
                }
            } else if (userRole === "MANAGER") {
                if (tgtRole === "EMPLOYEE") {
                    // allow only if that employee is part of one of the manager's teams
                    const isInManagerTeam = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].teamMember.findFirst({
                        where: {
                            userId: target.id,
                            team: {
                                managerId: userId
                            }
                        },
                        select: {
                            id: true
                        }
                    });
                    if (!isInManagerTeam) {
                        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                            ok: false,
                            error: "Managers can message an employee only if the employee belongs to their team"
                        }, {
                            status: 403
                        });
                    }
                }
            // manager->manager and manager->admin allowed
            } else {
                // EMPLOYEE
                if (tgtRole === "ADMIN") {
                    // employees can message admin? original design: employees cannot message other team managers? Your spec: "employees will be able to communicate within each other of that particular group or team in which they are assigned and with their respective manager." — they can message their manager but not admin.
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                        ok: false,
                        error: "Employees cannot message admin directly"
                    }, {
                        status: 403
                    });
                }
                // If target is manager: ensure manager is manager of employee's team
                if (tgtRole === "MANAGER") {
                    const managerIsOfEmployee = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].teamMember.findFirst({
                        where: {
                            userId,
                            team: {
                                managerId: target.id
                            }
                        },
                        select: {
                            id: true
                        }
                    });
                    if (!managerIsOfEmployee) {
                        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                            ok: false,
                            error: "Employee can message only their manager"
                        }, {
                            status: 403
                        });
                    }
                }
                // If target is employee: ensure both are in same team
                if (tgtRole === "EMPLOYEE") {
                    const commonTeam = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].teamMember.findFirst({
                        where: {
                            userId: target.id,
                            team: {
                                members: {
                                    some: {
                                        userId
                                    }
                                }
                            }
                        },
                        select: {
                            id: true
                        }
                    });
                    // simpler query: check if there exists a TeamMember row for employee target with team that also has a member userId
                    // fallback: check team intersection
                    if (!commonTeam) {
                        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                            ok: false,
                            error: "Employees can message only members of their team"
                        }, {
                            status: 403
                        });
                    }
                }
            }
        }
        // Passed ACL checks — create chat
        // For simplicity we create a chat with all participants as ChatMembers; map roles appropriately; do not mark admins as ChatMember for team chats (there is no team here).
        const participants = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].user.findMany({
            where: {
                id: {
                    in: uniqueMemberIds
                }
            },
            select: {
                id: true,
                role: true
            }
        });
        const chat = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chat.create({
            data: {
                name: name ?? null,
                type: "DIRECT",
                organization: orgId ? {
                    connect: {
                        id: orgId
                    }
                } : undefined,
                createdBy: {
                    connect: {
                        id: userId
                    }
                },
                members: {
                    create: participants.map((p)=>({
                            user: {
                                connect: {
                                    id: p.id
                                }
                            },
                            role: mapUserRoleToChatRole(p.role)
                        }))
                }
            },
            include: {
                members: {
                    include: {
                        user: {
                            select: {
                                id: true,
                                name: true,
                                email: true
                            }
                        }
                    }
                },
                createdBy: {
                    select: {
                        id: true,
                        name: true
                    }
                }
            }
        });
        // emit chat:created to participants & org room (best-effort)
        (async ()=>{
            try {
                const io = /*TURBOPACK member replacement*/ __turbopack_context__.g.io || /*TURBOPACK member replacement*/ __turbopack_context__.g._io || /*TURBOPACK member replacement*/ __turbopack_context__.g.socketServer;
                const payload = {
                    chat: {
                        id: chat.id,
                        name: chat.name
                    },
                    organizationId: orgId
                };
                if (io && typeof io.to === "function") {
                    for (const p of participants){
                        io.to(`user:${p.id}`).emit("chat:created", payload);
                    }
                    if (orgId) io.to(`org:${orgId}`).emit("chat:created", payload);
                } else if (io && typeof io.emit === "function") {
                    io.emit("chat:created", payload);
                }
            } catch (e) {
                console.warn("[api/chats] emit chat:created failed:", e);
            }
        })();
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: true,
            created: true,
            chat: normalizeChat(chat)
        }, {
            status: 201
        });
    } catch (err) {
        console.error("POST /api/chats error:", err);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: false,
            error: "Internal Server Error",
            chat: null
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__81bcc48e._.js.map
{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["// lib/prisma.ts\r\nimport { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line\r\n  var __prisma__: PrismaClient | undefined;\r\n}\r\nexport const prisma =\r\n  global.__prisma__ ??\r\n  new PrismaClient({\r\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"warn\", \"error\"] : [\"error\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.__prisma__ = prisma;\r\n"],"names":[],"mappings":"AAAA,gBAAgB;;;;;AAChB;;AAMO,MAAM,SACX,OAAO,UAAU,IACjB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAQ;KAAQ,GAAG;AAC7E;AAEF,wCAA2C,OAAO,UAAU,GAAG","debugId":null}},
    {"offset": {"line": 95, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/app/api/invites/finalize/route.ts"],"sourcesContent":["// src/app/api/invites/finalize/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport bcrypt from \"bcryptjs\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport crypto from \"crypto\";\r\nimport { prisma } from \"@/lib/prisma\";\r\n\r\n/**\r\n * POST /api/invites/finalize\r\n *\r\n * Accepts:\r\n *   { token?: string, password: string, name?: string, phone?: string, phoneVerified?: boolean }\r\n * or Authorization: Bearer <token>\r\n *\r\n * Behavior:\r\n *  - Validate token + password\r\n *  - Ensure invite exists, not expired, not already accepted\r\n *  - Ensure invite.email is not already registered under another org (prevent overlap)\r\n *  - Create user in a transaction, attach organization from invite\r\n *  - Create Profile and TeamMember (if invite.teamId present)\r\n *  - Mark invite.acceptedAt, status = ACCEPTED and \"consume\" the token in same transaction\r\n *    (we overwrite the token with a unique consumed value to preserve DB unique constraint).\r\n *  - Return 201 with userId/email/organizationId and optionally { token, redirect }\r\n *\r\n * Notes:\r\n *  - If you prefer to set token = null, migrate your Prisma schema so token is nullable (String?).\r\n *  - This implementation intentionally overwrites token with a unique consumed value to avoid\r\n *    unique-constraint errors on invite consumption when token column is non-nullable.\r\n */\r\n\r\n/* ---------- simple validators ---------- */\r\nfunction validatePassword(p: unknown) {\r\n  return typeof p === \"string\" && p.length >= 8;\r\n}\r\nfunction validateName(n: unknown) {\r\n  return n === undefined || (typeof n === \"string\" && n.trim().length > 0 && n.trim().length <= 200);\r\n}\r\n\r\n/* ---------- helper to generate a unique consumed token ---------- */\r\nfunction makeConsumedToken(originalToken: string | undefined) {\r\n  // safe prefix of original in case you want to keep some reference (slice short)\r\n  const prefix = (originalToken && typeof originalToken === \"string\" ? originalToken.slice(0, 20) : \"consumed\");\r\n  const suffix = crypto.randomBytes(12).toString(\"hex\"); // 24 hex chars, strong randomness\r\n  // keep total under typical varchar limits\r\n  return `${prefix}-consumed-${Date.now().toString(36)}-${suffix}`.slice(0, 255);\r\n}\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    // defensive parse\r\n    let body: any = {};\r\n    try {\r\n      body = (await req.json()) || {};\r\n    } catch {\r\n      body = {};\r\n    }\r\n\r\n    // token: body.token or Authorization: Bearer <token>\r\n    let token: string | null =\r\n      typeof body?.token === \"string\" && body.token.trim() ? body.token.trim() : null;\r\n\r\n    if (!token) {\r\n      const authHeader = req.headers.get(\"authorization\") || req.headers.get(\"Authorization\");\r\n      if (authHeader && typeof authHeader === \"string\" && authHeader.toLowerCase().startsWith(\"bearer \")) {\r\n        token = authHeader.slice(7).trim();\r\n      }\r\n    }\r\n\r\n    if (!token) {\r\n      return NextResponse.json(\r\n        { ok: false, message: \"Missing invite token (provide body.token or Authorization: Bearer <token>)\" },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    if (typeof token !== \"string\" || token.length < 16) {\r\n      return NextResponse.json({ ok: false, message: \"Invalid invite token\" }, { status: 400 });\r\n    }\r\n\r\n    // password + name + phone\r\n    const password = body?.password;\r\n    if (!validatePassword(password)) {\r\n      return NextResponse.json({ ok: false, message: \"Invalid password — must be at least 8 characters.\" }, { status: 400 });\r\n    }\r\n\r\n    const name = typeof body?.name === \"string\" && body.name.trim() ? body.name.trim() : undefined;\r\n    if (!validateName(name)) {\r\n      return NextResponse.json({ ok: false, message: \"Invalid name\" }, { status: 400 });\r\n    }\r\n\r\n    const phone = typeof body?.phone === \"string\" && body.phone.trim() ? body.phone.trim() : undefined;\r\n    const phoneVerifiedFlag = !!body?.phoneVerified;\r\n    const now = new Date();\r\n\r\n    /* ---------- transaction: create user, profile, teamMember, and consume invite ---------- */\r\n    const result = await prisma.$transaction(async (tx) => {\r\n      // 1) load invite by token\r\n      const invite = await tx.invite.findUnique({ where: { token } });\r\n      if (!invite) throw { code: \"INVITE_NOT_FOUND\" };\r\n\r\n      // 2) validate invite\r\n      if (invite.expiresAt && invite.expiresAt.getTime() <= now.getTime()) throw { code: \"INVITE_EXPIRED\" };\r\n      if (invite.acceptedAt) throw { code: \"INVITE_ALREADY_USED\" };\r\n      const invitedEmail = (invite.email || \"\").trim().toLowerCase();\r\n      if (!invitedEmail) throw { code: \"INVITE_MISSING_EMAIL\" };\r\n\r\n      // 3) ensure the invited email not already registered (global uniqueness)\r\n      const existing = await tx.user.findUnique({ where: { email: invitedEmail } });\r\n      if (existing) {\r\n        if (existing.organizationId && invite.organizationId && existing.organizationId !== invite.organizationId) {\r\n          throw { code: \"EMAIL_EXISTS_OTHER_ORG\" };\r\n        }\r\n        throw { code: \"EMAIL_ALREADY_REGISTERED\" };\r\n      }\r\n\r\n      // 4) ensure invite has organization\r\n      if (!invite.organizationId) throw { code: \"INVITE_MISSING_ORG\" };\r\n      const org = await tx.organization.findUnique({ where: { id: invite.organizationId } });\r\n      if (!org) throw { code: \"INVITE_ORG_NOT_FOUND\" };\r\n\r\n      // 5) hash password\r\n      const passwordHash = await bcrypt.hash(String(password), 10);\r\n\r\n      // 6) normalize role\r\n      const roleFromInvite = (invite.role || \"EMPLOYEE\") as string;\r\n      const normalizedRole = typeof roleFromInvite === \"string\" ? roleFromInvite.toUpperCase() : \"EMPLOYEE\";\r\n      const isManager = normalizedRole === \"MANAGER\";\r\n\r\n      // 7) build user payload\r\n      const createUserData: any = {\r\n        email: invitedEmail,\r\n        passwordHash,\r\n        name: name ?? null,\r\n        provider: \"email\",\r\n        emailVerified: true, // invited email is considered pre-verified\r\n        role: normalizedRole,\r\n        organization: { connect: { id: invite.organizationId } },\r\n        isActive: true,\r\n      };\r\n\r\n      if (phone) {\r\n        createUserData.phone = phone;\r\n        createUserData.phoneVerified = isManager ? true : !!phoneVerifiedFlag;\r\n      }\r\n\r\n      // 8) create the user\r\n      const newUser = await tx.user.create({ data: createUserData });\r\n\r\n      // 9) create profile\r\n      const profileData: any = { userId: newUser.id, displayName: name ?? undefined };\r\n      if (phone) {\r\n        profileData.phoneNumber = phone;\r\n        profileData.phoneVerified = isManager ? true : !!phoneVerifiedFlag;\r\n        if (profileData.phoneVerified) profileData.phoneVerifiedAt = now;\r\n      }\r\n      await tx.profile.create({ data: profileData });\r\n\r\n      // 10) create team membership when applicable (and team exists)\r\n      if (invite.teamId) {\r\n        const teamExists = await tx.team.findUnique({ where: { id: invite.teamId } });\r\n        if (teamExists) {\r\n          await tx.teamMember.create({\r\n            data: {\r\n              teamId: invite.teamId,\r\n              userId: newUser.id,\r\n              role: normalizedRole ?? \"EMPLOYEE\",\r\n            },\r\n          });\r\n        }\r\n      }\r\n\r\n      // 11) consume invite: update acceptedAt, status, and overwrite token with unique consumed value.\r\n      // We attempt multiple times if (extremely unlikely) the generated consumed token collides with an existing token.\r\n      const maxAttempts = 4;\r\n      let lastErr: any = null;\r\n      for (let attempt = 0; attempt < maxAttempts; attempt++) {\r\n        const consumedToken = makeConsumedToken(invite.token);\r\n        try {\r\n          await tx.invite.update({\r\n            where: { id: invite.id },\r\n            data: { acceptedAt: now, status: \"ACCEPTED\", token: consumedToken },\r\n          });\r\n          // success — break loop\r\n          lastErr = null;\r\n          break;\r\n        } catch (uErr: any) {\r\n          // If unique constraint on token triggered (very unlikely), retry with a new consumed token\r\n          lastErr = uErr;\r\n          // On final attempt we'll rethrow below\r\n        }\r\n      }\r\n      if (lastErr) {\r\n        // bubble up a recognizable error to outer catch\r\n        console.error(\"[invites/finalize] failed to consume invite token after retries:\", lastErr);\r\n        throw { code: \"INVITE_CONSUME_FAILED\", meta: lastErr };\r\n      }\r\n\r\n      return {\r\n        userId: newUser.id,\r\n        email: newUser.email,\r\n        organizationId: invite.organizationId ?? null,\r\n        role: normalizedRole,\r\n      };\r\n    });\r\n\r\n    // 12) Optionally sign a JWT if JWT_SECRET provided\r\n    let signedToken: string | undefined = undefined;\r\n    try {\r\n      const secret = process.env.JWT_SECRET;\r\n      if (secret) {\r\n        const payload = { sub: result.userId, email: result.email, org: result.organizationId, role: result.role };\r\n        const expiresIn = process.env.JWT_EXPIRES_IN || \"7d\";\r\n        signedToken = jwt.sign(payload, secret, { expiresIn });\r\n      }\r\n    } catch (jwtErr) {\r\n      console.error(\"[invites/finalize] failed to sign JWT:\", jwtErr);\r\n    }\r\n\r\n    // Redirect hint for frontend (choose page based on role). Keep conservative default to avoid 404s.\r\n    const redirect = result.role && /MANAGER/i.test(result.role) ? \"/dashboard/manager\" : \"/dashboard/employee/MySchedule\";\r\n\r\n    const responseBody: any = { ok: true, message: \"Account created\", ...result, redirect };\r\n    if (signedToken) responseBody.token = signedToken;\r\n\r\n    return NextResponse.json(responseBody, { status: 201 });\r\n  } catch (err: any) {\r\n    // map known transaction error codes thrown above\r\n    if (err && typeof err === \"object\" && \"code\" in err) {\r\n      switch (err.code) {\r\n        case \"INVITE_NOT_FOUND\":\r\n          return NextResponse.json({ ok: false, message: \"Invalid invite token\" }, { status: 404 });\r\n        case \"INVITE_EXPIRED\":\r\n          return NextResponse.json({ ok: false, message: \"Invite expired\" }, { status: 410 });\r\n        case \"INVITE_ALREADY_USED\":\r\n          return NextResponse.json({ ok: false, message: \"Invite already used\" }, { status: 410 });\r\n        case \"INVITE_MISSING_EMAIL\":\r\n          return NextResponse.json({ ok: false, message: \"Invite missing target email\" }, { status: 500 });\r\n        case \"EMAIL_ALREADY_REGISTERED\":\r\n          return NextResponse.json({ ok: false, message: \"Account already exists for this email\" }, { status: 409 });\r\n        case \"EMAIL_EXISTS_OTHER_ORG\":\r\n          return NextResponse.json({ ok: false, message: \"An account with this email exists under another organization\" }, { status: 409 });\r\n        case \"INVITE_MISSING_ORG\":\r\n          return NextResponse.json({ ok: false, message: \"Invite missing organization\" }, { status: 400 });\r\n        case \"INVITE_ORG_NOT_FOUND\":\r\n          return NextResponse.json({ ok: false, message: \"Invite organization not found\" }, { status: 404 });\r\n        case \"INVITE_CONSUME_FAILED\":\r\n          return NextResponse.json({ ok: false, message: \"Failed to consume invite token (please retry)\" }, { status: 500 });\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n\r\n    // Prisma unique constraint fallback\r\n    if (err && (err.code === \"P2002\" || err?.meta?.target)) {\r\n      const target = Array.isArray(err?.meta?.target) ? (err.meta.target as string[]).join(\", \") : err?.meta?.target;\r\n      console.error(\"[invites/finalize] Prisma unique constraint error:\", target, err);\r\n      return NextResponse.json({ ok: false, message: `Unique constraint failed: ${target}` }, { status: 409 });\r\n    }\r\n\r\n    console.error(\"[invites/finalize] Fatal error:\", err);\r\n    const isDev = process.env.NODE_ENV !== \"production\";\r\n    return NextResponse.json({ ok: false, message: isDev ? (err?.message || String(err)) : \"Server error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}
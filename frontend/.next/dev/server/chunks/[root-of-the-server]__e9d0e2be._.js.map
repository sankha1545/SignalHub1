{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/socket.ts"],"sourcesContent":["// src/lib/socket.ts\r\n// Small helper to call the socket server's /emit endpoint from backend code.\r\n// Usage:\r\n//   import { emitToRooms } from \"@/lib/socket\";\r\n//   await emitToRooms({ event: \"chat:created\", rooms: [\"user:123\",\"org:abc\"], payload: {...} });\r\n\r\nimport fetch from \"node-fetch\";\r\n\r\nconst SOCKET_SERVER_URL = process.env.SOCKET_SERVER_URL || process.env.NEXT_PUBLIC_SOCKET_URL || \"http://localhost:4001\";\r\nconst SOCKET_SERVER_KEY = process.env.SOCKET_SERVER_KEY || \"\";\r\n\r\ntype EmitArgs = {\r\n  event: string;\r\n  payload?: any;\r\n  rooms?: string[] | string;\r\n  excludeSocketId?: string;\r\n  timeoutMs?: number;\r\n};\r\n\r\nexport async function emitToRooms({ event, payload = {}, rooms, excludeSocketId, timeoutMs = 2000 }: EmitArgs) {\r\n  if (!SOCKET_SERVER_URL) return { ok: false, error: \"no socket server url\" };\r\n  if (!SOCKET_SERVER_KEY) {\r\n    // still allow if no key supplied (not recommended for prod)\r\n    console.warn(\"socket: no SOCKET_SERVER_KEY configured ‚Äî /emit endpoint not protected\");\r\n  }\r\n\r\n  const url = new URL(\"/emit\", SOCKET_SERVER_URL).toString();\r\n  const body = {\r\n    key: SOCKET_SERVER_KEY,\r\n    rooms,\r\n    event,\r\n    payload,\r\n    excludeSocketId,\r\n  };\r\n\r\n  try {\r\n    const controller = new AbortController();\r\n    const id = setTimeout(() => controller.abort(), timeoutMs);\r\n    const resp = await fetch(url, {\r\n      method: \"POST\",\r\n      headers: { \"Content-Type\": \"application/json\" },\r\n      body: JSON.stringify(body),\r\n      signal: controller.signal,\r\n    });\r\n    clearTimeout(id);\r\n    if (!resp.ok) {\r\n      const text = await resp.text().catch(() => \"\");\r\n      return { ok: false, status: resp.status, body: text };\r\n    }\r\n    const json = await resp.json().catch(() => ({}));\r\n    return { ok: true, result: json };\r\n  } catch (err: any) {\r\n    return { ok: false, error: String(err?.message ?? err) };\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,oBAAoB;AACpB,6EAA6E;AAC7E,SAAS;AACT,gDAAgD;AAChD,iGAAiG;;;;;AAEjG;;AAEA,MAAM,oBAAoB,QAAQ,GAAG,CAAC,iBAAiB,IAAI,QAAQ,GAAG,CAAC,sBAAsB,IAAI;AACjG,MAAM,oBAAoB,QAAQ,GAAG,CAAC,iBAAiB,IAAI;AAUpD,eAAe,YAAY,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC,EAAE,KAAK,EAAE,eAAe,EAAE,YAAY,IAAI,EAAY;IAC3G;;IACA,IAAI,CAAC,mBAAmB;QACtB,4DAA4D;QAC5D,QAAQ,IAAI,CAAC;IACf;IAEA,MAAM,MAAM,IAAI,IAAI,SAAS,mBAAmB,QAAQ;IACxD,MAAM,OAAO;QACX,KAAK;QACL;QACA;QACA;QACA;IACF;IAEA,IAAI;QACF,MAAM,aAAa,IAAI;QACvB,MAAM,KAAK,WAAW,IAAM,WAAW,KAAK,IAAI;QAChD,MAAM,OAAO,MAAM,IAAA,0KAAK,EAAC,KAAK;YAC5B,QAAQ;YACR,SAAS;gBAAE,gBAAgB;YAAmB;YAC9C,MAAM,KAAK,SAAS,CAAC;YACrB,QAAQ,WAAW,MAAM;QAC3B;QACA,aAAa;QACb,IAAI,CAAC,KAAK,EAAE,EAAE;YACZ,MAAM,OAAO,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,IAAM;YAC3C,OAAO;gBAAE,IAAI;gBAAO,QAAQ,KAAK,MAAM;gBAAE,MAAM;YAAK;QACtD;QACA,MAAM,OAAO,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,CAAC,CAAC;QAC9C,OAAO;YAAE,IAAI;YAAM,QAAQ;QAAK;IAClC,EAAE,OAAO,KAAU;QACjB,OAAO;YAAE,IAAI;YAAO,OAAO,OAAO,KAAK,WAAW;QAAK;IACzD;AACF","debugId":null}},
    {"offset": {"line": 200, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/socketAdapter.ts"],"sourcesContent":["// src/lib/socketAdapter.ts\r\n// Adapter to forward legacy `global.io` / `global._io` / `global.socketServer`\r\n// calls to the standalone socket server via the /emit HTTP endpoint.\r\n\r\nimport { emitToRooms } from \"@/lib/socket\";\r\n\r\ntype EmitFn = (event: string, payload?: any) => Promise<void> | void;\r\n\r\nfunction makeRoomEmitter(room: string | string[]) {\r\n  return {\r\n    emit: (event: string, payload?: any) => {\r\n      return emitToRooms({ event, payload, rooms: room });\r\n    },\r\n    // allow io.to(room).except(socketId).emit(...) pattern\r\n    except: (socketId: string) => ({\r\n      emit: (event: string, payload?: any) => {\r\n        return emitToRooms({ event, payload, rooms: room, excludeSocketId: socketId });\r\n      },\r\n    }),\r\n  };\r\n}\r\n\r\n// Single shared adapter instance\r\nconst adapter = {\r\n  /**\r\n   * io.emit(\"event\", payload)\r\n   *  -> broadcast globally\r\n   */\r\n  emit: ((event: string, payload?: any) => {\r\n    return emitToRooms({ event, payload });\r\n  }) as EmitFn,\r\n\r\n  /**\r\n   * io.to(\"room\").emit(\"event\", payload)\r\n   *  -> broadcast to specific room(s)\r\n   */\r\n  to: (room: string | string[]) => makeRoomEmitter(room),\r\n};\r\n\r\n// Attach to global only once\r\ndeclare global {\r\n  // eslint-disable-next-line no-var\r\n  var __socketAdapterInitialized: boolean | undefined;\r\n}\r\n\r\nfunction attachGlobals() {\r\n  if (global.__socketAdapterInitialized) return;\r\n  global.__socketAdapterInitialized = true;\r\n\r\n  // These are the names used in your API code:\r\n  // (global as any).io || (global as any)._io || (global as any).socketServer\r\n  const g: any = global;\r\n\r\n  if (!g.io) g.io = adapter;\r\n  if (!g._io) g._io = adapter;\r\n  if (!g.socketServer) g.socketServer = adapter;\r\n}\r\n\r\n// Run immediately on import (server-only)\r\nattachGlobals();\r\n\r\nexport { adapter as socketAdapter };\r\n"],"names":[],"mappings":"AAAA,2BAA2B;AAC3B,+EAA+E;AAC/E,qEAAqE;;;;;AAErE;;AAIA,SAAS,gBAAgB,IAAuB;IAC9C,OAAO;QACL,MAAM,CAAC,OAAe;YACpB,OAAO,IAAA,qIAAW,EAAC;gBAAE;gBAAO;gBAAS,OAAO;YAAK;QACnD;QACA,uDAAuD;QACvD,QAAQ,CAAC,WAAqB,CAAC;gBAC7B,MAAM,CAAC,OAAe;oBACpB,OAAO,IAAA,qIAAW,EAAC;wBAAE;wBAAO;wBAAS,OAAO;wBAAM,iBAAiB;oBAAS;gBAC9E;YACF,CAAC;IACH;AACF;AAEA,iCAAiC;AACjC,MAAM,UAAU;IACd;;;GAGC,GACD,MAAO,CAAC,OAAe;QACrB,OAAO,IAAA,qIAAW,EAAC;YAAE;YAAO;QAAQ;IACtC;IAEA;;;GAGC,GACD,IAAI,CAAC,OAA4B,gBAAgB;AACnD;AAQA,SAAS;IACP,IAAI,OAAO,0BAA0B,EAAE;IACvC,OAAO,0BAA0B,GAAG;IAEpC,6CAA6C;IAC7C,4EAA4E;IAC5E,MAAM,IAAS;IAEf,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG;IAClB,IAAI,CAAC,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG;IACpB,IAAI,CAAC,EAAE,YAAY,EAAE,EAAE,YAAY,GAAG;AACxC;AAEA,0CAA0C;AAC1C","debugId":null}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["// lib/prisma.ts\r\nimport { PrismaClient } from \"@prisma/client\";\r\n// near the top, before exports\r\nimport \"@/lib/socketAdapter\";\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line\r\n  var __prisma__: PrismaClient | undefined;\r\n}\r\nexport const prisma =\r\n  global.__prisma__ ??\r\n  new PrismaClient({\r\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"warn\", \"error\"] : [\"error\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.__prisma__ = prisma;\r\n"],"names":[],"mappings":"AAAA,gBAAgB;;;;;AAChB;AACA,+BAA+B;AAC/B;;;AAMO,MAAM,SACX,OAAO,UAAU,IACjB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAQ;KAAQ,GAAG;AAC7E;AAEF,wCAA2C,OAAO,UAAU,GAAG","debugId":null}},
    {"offset": {"line": 304, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/jwt.ts"],"sourcesContent":["// src/lib/jwt.ts\r\nimport jwt, { JwtPayload } from \"jsonwebtoken\";\r\n\r\nconst SECRET = process.env.JWT_SECRET;\r\nif (!SECRET) {\r\n  if (process.env.NODE_ENV === \"production\") {\r\n    throw new Error(\"JWT_SECRET environment variable must be set in production!\");\r\n  } else {\r\n    console.warn(\"[JWT] Using fallback secret for development\");\r\n  }\r\n}\r\n\r\n/**\r\n * üîê Create a short-lived temp token (email/phone verification)\r\n */\r\nexport function signTemp(payload: Record<string, any>, expiresIn: string = \"15m\"): string {\r\n  const safePayload = { ...payload };\r\n  delete safePayload.exp;\r\n  return jwt.sign(safePayload, SECRET!, { expiresIn });\r\n}\r\n\r\n/**\r\n * ‚úÖ Verify short-lived temp tokens\r\n * Returns payload object or null if invalid/expired\r\n */\r\nexport function verifyTemp(token: string): Record<string, any> | null {\r\n  try {\r\n    return jwt.verify(token, SECRET!) as Record<string, any>;\r\n  } catch (err) {\r\n    console.warn(\"[JWT] verifyTemp failed:\", (err as Error).message);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * üíæ Create a long-lived session token for logged-in users\r\n */\r\nexport function signSession(payload: Record<string, any>, expiresIn: string = \"7d\"): string {\r\n  const safePayload = { ...payload };\r\n  delete safePayload.exp;\r\n  return jwt.sign(safePayload, SECRET!, { expiresIn });\r\n}\r\n\r\n/**\r\n * üîé Verify a session token\r\n * Returns payload object or null if invalid/expired\r\n */\r\nexport function verifySession(token: string): Record<string, any> | null {\r\n  try {\r\n    return jwt.verify(token, SECRET!) as Record<string, any>;\r\n  } catch (err) {\r\n    console.warn(\"[JWT] verifySession failed:\", (err as Error).message);\r\n    return null;\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,iBAAiB;;;;;;;;;;;AACjB;;AAEA,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU;AACrC,IAAI,CAAC,QAAQ;IACX;;SAEO;QACL,QAAQ,IAAI,CAAC;IACf;AACF;AAKO,SAAS,SAAS,OAA4B,EAAE,YAAoB,KAAK;IAC9E,MAAM,cAAc;QAAE,GAAG,OAAO;IAAC;IACjC,OAAO,YAAY,GAAG;IACtB,OAAO,kJAAG,CAAC,IAAI,CAAC,aAAa,QAAS;QAAE;IAAU;AACpD;AAMO,SAAS,WAAW,KAAa;IACtC,IAAI;QACF,OAAO,kJAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAO,KAAK;QACZ,QAAQ,IAAI,CAAC,4BAA4B,AAAC,IAAc,OAAO;QAC/D,OAAO;IACT;AACF;AAKO,SAAS,YAAY,OAA4B,EAAE,YAAoB,IAAI;IAChF,MAAM,cAAc;QAAE,GAAG,OAAO;IAAC;IACjC,OAAO,YAAY,GAAG;IACtB,OAAO,kJAAG,CAAC,IAAI,CAAC,aAAa,QAAS;QAAE;IAAU;AACpD;AAMO,SAAS,cAAc,KAAa;IACzC,IAAI;QACF,OAAO,kJAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAO,KAAK;QACZ,QAAQ,IAAI,CAAC,+BAA+B,AAAC,IAAc,OAAO;QAClE,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 363, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/auth.ts"],"sourcesContent":["// src/lib/auth.ts\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { verifySession } from \"@/lib/jwt\";\r\n\r\nexport type SessionUser = {\r\n  id: string;\r\n  email?: string | null;\r\n  role: string;\r\n  organizationId?: string | null;\r\n};\r\n\r\nexport async function getSessionUser(req: Request): Promise<SessionUser | null> {\r\n  try {\r\n    // 1Ô∏è‚É£ Prefer Authorization header: \"Bearer <token>\"\r\n    let token: string | null = null;\r\n    const authHeader = req.headers.get(\"authorization\");\r\n    if (authHeader?.startsWith(\"Bearer \")) {\r\n      token = authHeader.slice(\"Bearer \".length).trim();\r\n    }\r\n\r\n    // 2Ô∏è‚É£ Fallback to cookies\r\n    if (!token) {\r\n      const cookieHeader = req.headers.get(\"cookie\") || \"\";\r\n      const cookies: Record<string, string> = Object.fromEntries(\r\n        cookieHeader\r\n          .split(\";\")\r\n          .map(c => c.trim().split(\"=\"))\r\n          .map(([k, v]) => [decodeURIComponent(k), decodeURIComponent(v)])\r\n      );\r\n      token = cookies[\"session\"] || cookies[\"token\"] || null;\r\n    }\r\n\r\n    if (!token) return null;\r\n\r\n    // 3Ô∏è‚É£ Verify token safely\r\n    const payload = verifySession(token);\r\n    if (!payload?.id) return null;\r\n\r\n    // 4Ô∏è‚É£ Fetch user from DB\r\n    const user = await prisma.user.findUnique({ where: { id: payload.id } });\r\n    if (!user) return null;\r\n\r\n    return {\r\n      id: user.id,\r\n      email: user.email ?? null,\r\n      role: user.role,\r\n      organizationId: user.organizationId,\r\n    };\r\n  } catch (err: any) {\r\n    console.warn(\"[getSessionUser] error:\", err?.message || err);\r\n    return null;\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,kBAAkB;;;;;AAClB;AACA;;;AASO,eAAe,eAAe,GAAY;IAC/C,IAAI;QACF,oDAAoD;QACpD,IAAI,QAAuB;QAC3B,MAAM,aAAa,IAAI,OAAO,CAAC,GAAG,CAAC;QACnC,IAAI,YAAY,WAAW,YAAY;YACrC,QAAQ,WAAW,KAAK,CAAC,UAAU,MAAM,EAAE,IAAI;QACjD;QAEA,0BAA0B;QAC1B,IAAI,CAAC,OAAO;YACV,MAAM,eAAe,IAAI,OAAO,CAAC,GAAG,CAAC,aAAa;YAClD,MAAM,UAAkC,OAAO,WAAW,CACxD,aACG,KAAK,CAAC,KACN,GAAG,CAAC,CAAA,IAAK,EAAE,IAAI,GAAG,KAAK,CAAC,MACxB,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,GAAK;oBAAC,mBAAmB;oBAAI,mBAAmB;iBAAG;YAEnE,QAAQ,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,QAAQ,IAAI;QACpD;QAEA,IAAI,CAAC,OAAO,OAAO;QAEnB,0BAA0B;QAC1B,MAAM,UAAU,IAAA,oIAAa,EAAC;QAC9B,IAAI,CAAC,SAAS,IAAI,OAAO;QAEzB,yBAAyB;QACzB,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE,IAAI,QAAQ,EAAE;YAAC;QAAE;QACtE,IAAI,CAAC,MAAM,OAAO;QAElB,OAAO;YACL,IAAI,KAAK,EAAE;YACX,OAAO,KAAK,KAAK,IAAI;YACrB,MAAM,KAAK,IAAI;YACf,gBAAgB,KAAK,cAAc;QACrC;IACF,EAAE,OAAO,KAAU;QACjB,QAAQ,IAAI,CAAC,2BAA2B,KAAK,WAAW;QACxD,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 415, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/app/api/teams/%5Bid%5D/route.ts"],"sourcesContent":["// src/app/api/teams/[id]/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { getSessionUser } from \"@/lib/auth\"; // optional helper; if absent make sure it's a noop or remove\r\n\r\n/**\r\n * Route: /api/teams/[id]\r\n *\r\n * Handlers:\r\n *  - GET    -> fetch team (with manager + members)\r\n *  - PUT    -> update team fields and (optionally) replace members (keeps chat members in sync)\r\n *  - DELETE -> delete team and its members (attempts to cleanup related chat)\r\n *\r\n * Notes:\r\n *  - In App Router handlers the `params` argument can be a Promise; always `await params`.\r\n *  - Defensive: when Prisma doesn't have optional UI fields, it retries without them.\r\n */\r\n\r\n/* ----------------- Helpers ----------------- */\r\nfunction jsonError(message: string, status = 400) {\r\n  return NextResponse.json({ ok: false, message }, { status });\r\n}\r\n\r\nasync function resolveSessionOrganizationId(req: Request): Promise<string | null> {\r\n  try {\r\n    if (typeof getSessionUser === \"function\") {\r\n      const session = await (getSessionUser as any)(req).catch(() => null);\r\n      if (session?.organizationId) return String(session.organizationId);\r\n    }\r\n  } catch (e: any) {\r\n    // swallow session helper errors\r\n    console.warn(\"[api/teams/[id]] getSessionUser error:\", e?.message ?? e);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction isValidId(v: any) {\r\n  return typeof v === \"string\" && v.trim().length > 0;\r\n}\r\n\r\n/**\r\n * Map User.role (Role enum) -> ChatMember.role (ChatRole enum)\r\n * ChatRole values: \"MEMBER\" | \"MANAGER\" | \"ADMIN\"\r\n * We only assign MANAGER for managers; admins handled separately (admins should not be added as ChatMember in team chats).\r\n */\r\nfunction mapUserRoleToChatRole(userRole: string | null | undefined) {\r\n  if (userRole === \"MANAGER\") return \"MANAGER\";\r\n  // other roles (ADMIN, EMPLOYEE) map to MEMBER for chat membership purposes; ADMIN will be handled specially\r\n  return \"MEMBER\";\r\n}\r\n\r\n/* ---------- GET /api/teams/:id ---------- */\r\nexport async function GET(req: Request, context: { params: Promise<{ id?: string }> }) {\r\n  try {\r\n    const paramsResolved = await context.params;\r\n    const id = paramsResolved?.id;\r\n    if (!isValidId(id)) return jsonError(\"Missing team id\", 400);\r\n\r\n    const team = await prisma.team.findUnique({\r\n      where: { id },\r\n      include: {\r\n        manager: { select: { id: true, name: true, email: true, role: true } },\r\n        members: { select: { id: true, role: true, user: { select: { id: true, name: true, email: true } } } },\r\n      },\r\n    });\r\n\r\n    if (!team) return jsonError(\"Team not found\", 404);\r\n\r\n    // normalize shape for frontend (keeps returned object predictable)\r\n    const response = {\r\n      id: team.id,\r\n      name: team.name,\r\n      description: team.description ?? null,\r\n      managerId: (team as any).managerId ?? null,\r\n      manager: team.manager ? { id: team.manager.id, name: team.manager.name, email: team.manager.email } : null,\r\n      // optional UI metadata (only present if schema defines them)\r\n      featured: (team as any).featured ?? false,\r\n      gradient: (team as any).gradient ?? null,\r\n      projects: typeof (team as any).projects !== \"undefined\" ? Number((team as any).projects ?? 0) : null,\r\n      completion: typeof (team as any).completion !== \"undefined\" ? Number((team as any).completion ?? 0) : null,\r\n      members: (team.members ?? []).map((m) => ({\r\n        teamMemberId: m.id,\r\n        userId: m.user?.id ?? null,\r\n        name: m.user?.name ?? null,\r\n        email: m.user?.email ?? null,\r\n        role: m.role ?? null,\r\n      })),\r\n      organizationId: team.organizationId,\r\n      createdAt: team.createdAt?.toISOString?.() ?? null,\r\n      updatedAt: (team as any).updatedAt?.toISOString?.() ?? null,\r\n    };\r\n\r\n    return NextResponse.json({ ok: true, team: response }, { status: 200 });\r\n  } catch (err: any) {\r\n    console.error(\"[api/teams/[id]][GET] error:\", err);\r\n    const isDev = process.env.NODE_ENV !== \"production\";\r\n    return NextResponse.json({ ok: false, message: isDev ? (err?.message || String(err)) : \"Server error\" }, { status: 500 });\r\n  }\r\n}\r\n\r\n/* ---------- PUT /api/teams/:id ---------- */\r\n/**\r\n * Expected body examples:\r\n *  - Partial update:\r\n *    { name: \"New name\" }\r\n *  - Replace members:\r\n *    { memberUserIds: [\"uid1\",\"uid2\"] }\r\n *  - Set manager to null:\r\n *    { managerId: null }\r\n *  - Optional UI metadata (if your schema supports them):\r\n *    { featured: true, gradient: \"from-blue-500 to-cyan-500\", projects: 2, completion: 60 }\r\n */\r\nexport async function PUT(req: Request, context: { params: Promise<{ id?: string }> }) {\r\n  try {\r\n    const paramsResolved = await context.params;\r\n    const id = paramsResolved?.id;\r\n    if (!isValidId(id)) return jsonError(\"Missing team id\", 400);\r\n\r\n    const body = (await req.json().catch(() => ({}))) ?? {};\r\n    const {\r\n      name,\r\n      description = undefined, // undefined => not provided; null => explicitly clear\r\n      managerId = undefined, // undefined => not provided; null => clear manager\r\n      memberUserIds = undefined, // undefined => leave members alone; array => replace\r\n      // optional UI metadata that UI may send (only set if provided)\r\n      featured = undefined,\r\n      gradient = undefined,\r\n      projects = undefined,\r\n      completion = undefined,\r\n    } = body;\r\n\r\n    // optional session org check\r\n    const sessionOrg = await resolveSessionOrganizationId(req);\r\n\r\n    // load team and ensure it exists\r\n    const existing = await prisma.team.findUnique({ where: { id }, select: { id: true, organizationId: true } });\r\n    if (!existing) return jsonError(\"Team not found\", 404);\r\n\r\n    if (sessionOrg && existing.organizationId !== sessionOrg) return jsonError(\"Unauthorized for this organization\", 403);\r\n\r\n    // validate managerId (if provided)\r\n    if (managerId !== undefined) {\r\n      if (managerId !== null && !isValidId(managerId)) return jsonError(\"Invalid managerId\", 400);\r\n      if (managerId) {\r\n        const mgr = await prisma.user.findUnique({ where: { id: managerId }, select: { id: true, organizationId: true } });\r\n        if (!mgr) return jsonError(\"Manager user not found\", 404);\r\n        if (mgr.organizationId !== existing.organizationId) return jsonError(\"Manager must belong to same organization\", 400);\r\n      }\r\n    }\r\n\r\n    // validate memberUserIds (if provided)\r\n    let memberIds: string[] | null = null;\r\n    if (memberUserIds !== undefined) {\r\n      if (!Array.isArray(memberUserIds)) return jsonError(\"memberUserIds must be an array\", 400);\r\n      memberIds = Array.from(new Set(memberUserIds.filter((v: any) => typeof v === \"string\")));\r\n      if (memberIds.length > 0) {\r\n        const users = await prisma.user.findMany({\r\n          where: { id: { in: memberIds } },\r\n          select: { id: true, organizationId: true },\r\n        });\r\n        const found = new Set(users.map((u) => u.id));\r\n        for (const uid of memberIds) {\r\n          if (!found.has(uid)) return jsonError(`Member user not found: ${uid}`, 404);\r\n        }\r\n        for (const u of users) {\r\n          if (u.organizationId !== existing.organizationId) return jsonError(\"All member users must belong to the same organization\", 400);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Build update data (only include properties that were provided)\r\n    const updateDataCandidate: any = {};\r\n    if (name !== undefined) updateDataCandidate.name = String(name).trim();\r\n    if (description !== undefined) updateDataCandidate.description = description === null ? null : String(description).trim();\r\n    if (managerId !== undefined) {\r\n      // manager relation update: connect or disconnect\r\n      if (managerId) updateDataCandidate.manager = { connect: { id: managerId } };\r\n      else updateDataCandidate.manager = { disconnect: true };\r\n    }\r\n\r\n    // include optional UI metadata if provided by client\r\n    if (featured !== undefined) updateDataCandidate.featured = featured;\r\n    if (gradient !== undefined) updateDataCandidate.gradient = gradient;\r\n    if (projects !== undefined) updateDataCandidate.projects = typeof projects === \"number\" ? projects : Number(projects ?? 0);\r\n    if (completion !== undefined) updateDataCandidate.completion = typeof completion === \"number\" ? completion : Number(completion ?? 0);\r\n\r\n    // Attempt update in transaction. Because some Prisma schemas may NOT have the optional UI fields,\r\n    // we try once with the full update data; if Prisma complains about unknown fields (validation error),\r\n    // we retry without the optional UI fields.\r\n    let transactionResult: any = null;\r\n    try {\r\n      transactionResult = await prisma.$transaction(async (tx) => {\r\n        const updatedTeam = await tx.team.update({\r\n          where: { id },\r\n          data: updateDataCandidate,\r\n          select: { id: true, name: true, description: true, organizationId: true, managerId: true },\r\n        });\r\n\r\n        let members = [];\r\n        if (memberIds !== null) {\r\n          // replace members: delete then createMany (skipDuplicates for safety)\r\n          await tx.teamMember.deleteMany({ where: { teamId: id } });\r\n          if (memberIds.length > 0) {\r\n            const createManyData = memberIds.map((uid) => ({ teamId: id, userId: uid, role: \"EMPLOYEE\" }));\r\n            await tx.teamMember.createMany({ data: createManyData, skipDuplicates: true });\r\n            members = await tx.teamMember.findMany({\r\n              where: { teamId: id },\r\n              select: { id: true, role: true, user: { select: { id: true, name: true, email: true } } },\r\n            });\r\n          }\r\n        } else {\r\n          // not replacing members => return existing members\r\n          members = await tx.teamMember.findMany({\r\n            where: { teamId: id },\r\n            select: { id: true, role: true, user: { select: { id: true, name: true, email: true } } },\r\n          });\r\n        }\r\n\r\n        return { team: updatedTeam, members };\r\n      });\r\n    } catch (err: any) {\r\n      // detect Prisma unknown argument/validation error and retry without optional UI fields\r\n      const message = String(err?.message || err);\r\n      const unknownArg = /Unknown argument[s]?\\s+`?(featured|gradient|projects|completion)`?/i.test(message) || /Unknown arg/i.test(message);\r\n      if (unknownArg) {\r\n        // remove optional UI keys and retry\r\n        const safeUpdateData: any = { ...updateDataCandidate };\r\n        delete safeUpdateData.featured;\r\n        delete safeUpdateData.gradient;\r\n        delete safeUpdateData.projects;\r\n        delete safeUpdateData.completion;\r\n\r\n        transactionResult = await prisma.$transaction(async (tx) => {\r\n          const updatedTeam = await tx.team.update({\r\n            where: { id },\r\n            data: safeUpdateData,\r\n            select: { id: true, name: true, description: true, organizationId: true, managerId: true },\r\n          });\r\n\r\n          let members = [];\r\n          if (memberIds !== null) {\r\n            await tx.teamMember.deleteMany({ where: { teamId: id } });\r\n            if (memberIds.length > 0) {\r\n              const createManyData = memberIds.map((uid) => ({ teamId: id, userId: uid, role: \"EMPLOYEE\" }));\r\n              await tx.teamMember.createMany({ data: createManyData, skipDuplicates: true });\r\n              members = await tx.teamMember.findMany({\r\n                where: { teamId: id },\r\n                select: { id: true, role: true, user: { select: { id: true, name: true, email: true } } },\r\n              });\r\n            }\r\n          } else {\r\n            members = await tx.teamMember.findMany({\r\n              where: { teamId: id },\r\n              select: { id: true, role: true, user: { select: { id: true, name: true, email: true } } },\r\n            });\r\n          }\r\n\r\n          return { team: updatedTeam, members };\r\n        });\r\n      } else {\r\n        // rethrow other errors\r\n        throw err;\r\n      }\r\n    }\r\n\r\n    // load full team for response (includes manager and members)\r\n    const teamFull = await prisma.team.findUnique({\r\n      where: { id },\r\n      include: {\r\n        manager: { select: { id: true, name: true, email: true } },\r\n        members: { select: { id: true, role: true, user: { select: { id: true, name: true, email: true } } } },\r\n      },\r\n    });\r\n\r\n    if (!teamFull) return jsonError(\"Team not found after update (unexpected)\", 500);\r\n\r\n    const response = {\r\n      id: teamFull.id,\r\n      name: teamFull.name,\r\n      description: teamFull.description ?? null,\r\n      manager: teamFull.manager ? { id: teamFull.manager.id, name: teamFull.manager.name, email: teamFull.manager.email } : null,\r\n      // optional meta (present only if schema supports them)\r\n      featured: (teamFull as any).featured ?? false,\r\n      gradient: (teamFull as any).gradient ?? null,\r\n      projects: typeof (teamFull as any).projects !== \"undefined\" ? Number((teamFull as any).projects ?? 0) : null,\r\n      completion: typeof (teamFull as any).completion !== \"undefined\" ? Number((teamFull as any).completion ?? 0) : null,\r\n      members: (teamFull.members ?? []).map((m) => ({\r\n        teamMemberId: m.id,\r\n        userId: m.user?.id ?? null,\r\n        name: m.user?.name ?? null,\r\n        email: m.user?.email ?? null,\r\n        role: m.role ?? null,\r\n      })),\r\n      organizationId: teamFull.organizationId,\r\n      createdAt: teamFull.createdAt?.toISOString?.() ?? null,\r\n      updatedAt: (teamFull as any).updatedAt?.toISOString?.() ?? null,\r\n    };\r\n\r\n    // -----------------------------\r\n    // CHAT SYNC (best-effort): if the team has a group chat, sync chat members to match team membership\r\n    // -----------------------------\r\n    (async () => {\r\n      try {\r\n        if (!(prisma as any).chat || !(prisma as any).chatMember) {\r\n          // Chat model not present; nothing to do\r\n          return;\r\n        }\r\n\r\n        // find chat for this team (assumes chat.teamId relation exists)\r\n        const teamChat = await (prisma as any).chat.findFirst({\r\n          where: { teamId: id },\r\n          select: { id: true, organizationId: true, name: true },\r\n        });\r\n\r\n        if (!teamChat) {\r\n          // no chat for this team; nothing to sync\r\n          return;\r\n        }\r\n\r\n        const chatId = teamChat.id;\r\n\r\n        // Build the intended set of userIds for the chat: manager + members (do NOT include org admins)\r\n        const intended = new Set<string>();\r\n        if (teamFull.manager?.id) intended.add(teamFull.manager.id);\r\n        for (const m of teamFull.members ?? []) {\r\n          if (m.userId) intended.add(m.userId);\r\n        }\r\n\r\n        // fetch existing chat members (include role so we can handle admin rows)\r\n        const existingChatMembers = await (prisma as any).chatMember.findMany({\r\n          where: { chatId },\r\n          select: { id: true, userId: true, role: true },\r\n        });\r\n\r\n        // Enforce invariant: admins should not be present in ChatMember for team chats.\r\n        const adminRows = existingChatMembers.filter((cm: any) => String(cm.role).toUpperCase() === \"ADMIN\");\r\n        if (adminRows.length > 0) {\r\n          const adminRowIds = adminRows.map((r: any) => r.id);\r\n          try {\r\n            await (prisma as any).chatMember.deleteMany({ where: { id: { in: adminRowIds } } });\r\n            // emit removal events for admins removed (best-effort)\r\n            try {\r\n              const io = (global as any).io || (global as any)._io || (global as any).socketServer;\r\n              if (io && typeof io.to === \"function\") {\r\n                for (const r of adminRows) {\r\n                  io.to(`user:${r.userId}`).emit(\"chat:member:removed\", { chatId, userId: r.userId });\r\n                }\r\n               io.to(`chat:${chatId}`).emit(\"chat:member:list:updated\", { chatId });\r\n\r\n              }\r\n            } catch (e) {\r\n              // ignore emit failures\r\n            }\r\n          } catch (e) {\r\n            console.warn(\"[api/teams] failed to remove admin ChatMember rows (non-fatal):\", e);\r\n          }\r\n        }\r\n\r\n        const existingUserIds = new Set(existingChatMembers.map((cm: any) => cm.userId));\r\n\r\n        // Determine additions and removals (after admin cleanup)\r\n        const toAdd = Array.from(intended).filter((uid) => !existingUserIds.has(uid));\r\n        const toRemove = existingChatMembers.filter((cm: any) => !intended.has(cm.userId));\r\n\r\n        // Remove chat members that are no longer part of the team\r\n        if (toRemove.length > 0) {\r\n          const removeIds = toRemove.map((r: any) => r.id);\r\n          await (prisma as any).chatMember.deleteMany({ where: { id: { in: removeIds } } });\r\n          // emit removed events\r\n          try {\r\n            const io = (global as any).io || (global as any)._io || (global as any).socketServer;\r\n            if (io && typeof io.to === \"function\") {\r\n              for (const r of toRemove) {\r\n                io.to(`user:${r.userId}`).emit(\"chat:member:removed\", { chatId, userId: r.userId });\r\n              }\r\n              io.to(`chat:${chatId}`).emit(\"chat:member:list:updated\", { chatId });\r\n            }\r\n          } catch (e) {\r\n            console.warn(\"[api/teams] chat:member:removed emit failed:\", e);\r\n          }\r\n        }\r\n\r\n        // Add new chat members (skip org admins)\r\n        if (toAdd.length > 0) {\r\n          // Filter out org admins from toAdd (admins should not be chat members)\r\n          const usersForAdd = await prisma.user.findMany({\r\n            where: { id: { in: toAdd } },\r\n            select: { id: true, role: true },\r\n          });\r\n\r\n          const filteredUsersForAdd = usersForAdd.filter((u) => String(u.role).toUpperCase() !== \"ADMIN\");\r\n\r\n          const chatMemberRows = filteredUsersForAdd.map((u) => ({\r\n            chatId,\r\n            userId: u.id,\r\n            role: mapUserRoleToChatRole(u.role),\r\n          }));\r\n\r\n          if (chatMemberRows.length > 0) {\r\n            await (prisma as any).chatMember.createMany({ data: chatMemberRows, skipDuplicates: true });\r\n          }\r\n\r\n          // emit added events\r\n          try {\r\n            const io = (global as any).io || (global as any)._io || (global as any).socketServer;\r\n            if (io && typeof io.to === \"function\") {\r\n              for (const u of filteredUsersForAdd) {\r\n                io.to(`user:${u.id}`).emit(\"chat:member:added\", { chatId, user: { id: u.id, role: mapUserRoleToChatRole(u.role) } });\r\n              }\r\n              io.to(`chat:${chatId}`).emit(\"chat:member:list:updated\", { chatId });\r\n            }\r\n          } catch (e) {\r\n            console.warn(\"[api/teams] chat:member:added emit failed:\", e);\r\n          }\r\n        }\r\n      } catch (syncErr) {\r\n        console.warn(\"[api/teams] chat sync failed (non-fatal):\", syncErr);\r\n      }\r\n    })();\r\n\r\n    // Emit team updated event to org room (best-effort)\r\n    (async () => {\r\n      try {\r\n        const io = (global as any).io || (global as any)._io || (global as any).socketServer;\r\n        if (io && typeof io.to === \"function\") {\r\n          io.to(`org:${response.organizationId}`).emit(\"team:updated\", { team: response });\r\n        } else if (io && typeof io.emit === \"function\") {\r\n          io.emit(\"team:updated\", { team: response });\r\n        }\r\n      } catch (e) {\r\n        console.warn(\"[api/teams] team:updated emit failed:\", e);\r\n      }\r\n    })();\r\n\r\n    return NextResponse.json({ ok: true, team: response }, { status: 200 });\r\n  } catch (err: any) {\r\n    console.error(\"[api/teams/[id]][PUT] error:\", err);\r\n    const isDev = process.env.NODE_ENV !== \"production\";\r\n    return NextResponse.json({ ok: false, message: isDev ? (err?.message || String(err)) : \"Server error\" }, { status: 500 });\r\n  }\r\n}\r\n\r\n/* ---------- DELETE /api/teams/:id ---------- */\r\nexport async function DELETE(req: Request, context: { params: Promise<{ id?: string }> }) {\r\n  try {\r\n    const paramsResolved = await context.params;\r\n    const id = paramsResolved?.id;\r\n    if (!isValidId(id)) return jsonError(\"Missing team id\", 400);\r\n\r\n    const sessionOrg = await resolveSessionOrganizationId(req);\r\n\r\n    const team = await prisma.team.findUnique({ where: { id }, select: { id: true, organizationId: true } });\r\n    if (!team) return jsonError(\"Team not found\", 404);\r\n    if (sessionOrg && team.organizationId !== sessionOrg) return jsonError(\"Unauthorized for this organization\", 403);\r\n\r\n    // Delete members then team to avoid FK problems\r\n    await prisma.$transaction(async (tx) => {\r\n      await tx.teamMember.deleteMany({ where: { teamId: id } });\r\n      await tx.team.delete({ where: { id } });\r\n    });\r\n\r\n    // best-effort: cleanup or archive the related chat for this team\r\n    (async () => {\r\n      try {\r\n        if ((prisma as any).chat) {\r\n          const teamChat = await (prisma as any).chat.findFirst({ where: { teamId: id }, select: { id: true } });\r\n          if (teamChat) {\r\n            // try delete chat members and chat itself (non-fatal)\r\n            try {\r\n              if ((prisma as any).chatMember) {\r\n                await (prisma as any).chatMember.deleteMany({ where: { chatId: teamChat.id } });\r\n              }\r\n            } catch (e) {\r\n              console.warn(\"[api/teams] cleaning chat members failed:\", e);\r\n            }\r\n            try {\r\n              // if schema supports \"archived\" field prefer archiving instead of delete\r\n              if ((prisma as any).chat.update) {\r\n                // attempt archive if field exists\r\n                try {\r\n                  await (prisma as any).chat.update({ where: { id: teamChat.id }, data: { archived: true } });\r\n                } catch (e) {\r\n                  // no archived field ‚Äî fallback to delete\r\n                  await (prisma as any).chat.delete({ where: { id: teamChat.id } });\r\n                }\r\n              }\r\n            } catch (e) {\r\n              console.warn(\"[api/teams] deleting/archiving chat failed:\", e);\r\n            }\r\n            // emit removal event\r\n            try {\r\n              const io = (global as any).io || (global as any)._io || (global as any).socketServer;\r\n              if (io && typeof io.to === \"function\") {\r\n                io.to(`org:${team.organizationId}`).emit(\"team:deleted\", { teamId: id, chatId: teamChat.id });\r\n                io.to(`chat:${teamChat.id}`).emit(\"chat:archived\", { chatId: teamChat.id });\r\n              } else if (io && typeof io.emit === \"function\") {\r\n                io.emit(\"team:deleted\", { teamId: id, chatId: teamChat.id });\r\n              }\r\n            } catch (e) {\r\n              console.warn(\"[api/teams] emit after chat cleanup failed:\", e);\r\n            }\r\n          }\r\n        }\r\n      } catch (cleanupErr) {\r\n        console.warn(\"[api/teams] best-effort chat cleanup failed:\", cleanupErr);\r\n      }\r\n    })();\r\n\r\n    return NextResponse.json({ ok: true, message: \"Team deleted\" }, { status: 200 });\r\n  } catch (err: any) {\r\n    console.error(\"[api/teams/[id]][DELETE] error:\", err);\r\n    const isDev = process.env.NODE_ENV !== \"production\";\r\n    return NextResponse.json({ ok: false, message: isDev ? (err?.message || String(err)) : \"Server error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}
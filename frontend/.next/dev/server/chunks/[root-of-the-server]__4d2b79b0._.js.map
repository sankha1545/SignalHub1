{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/socket.ts"],"sourcesContent":["// src/lib/socket.ts\r\n// Small helper to call the socket server's /emit endpoint from backend code.\r\n// Usage:\r\n//   import { emitToRooms } from \"@/lib/socket\";\r\n//   await emitToRooms({ event: \"chat:created\", rooms: [\"user:123\",\"org:abc\"], payload: {...} });\r\n\r\nimport fetch from \"node-fetch\";\r\n\r\nconst SOCKET_SERVER_URL = process.env.SOCKET_SERVER_URL || process.env.NEXT_PUBLIC_SOCKET_URL || \"http://localhost:4001\";\r\nconst SOCKET_SERVER_KEY = process.env.SOCKET_SERVER_KEY || \"\";\r\n\r\ntype EmitArgs = {\r\n  event: string;\r\n  payload?: any;\r\n  rooms?: string[] | string;\r\n  excludeSocketId?: string;\r\n  timeoutMs?: number;\r\n};\r\n\r\nexport async function emitToRooms({ event, payload = {}, rooms, excludeSocketId, timeoutMs = 2000 }: EmitArgs) {\r\n  if (!SOCKET_SERVER_URL) return { ok: false, error: \"no socket server url\" };\r\n  if (!SOCKET_SERVER_KEY) {\r\n    // still allow if no key supplied (not recommended for prod)\r\n    console.warn(\"socket: no SOCKET_SERVER_KEY configured ‚Äî /emit endpoint not protected\");\r\n  }\r\n\r\n  const url = new URL(\"/emit\", SOCKET_SERVER_URL).toString();\r\n  const body = {\r\n    key: SOCKET_SERVER_KEY,\r\n    rooms,\r\n    event,\r\n    payload,\r\n    excludeSocketId,\r\n  };\r\n\r\n  try {\r\n    const controller = new AbortController();\r\n    const id = setTimeout(() => controller.abort(), timeoutMs);\r\n    const resp = await fetch(url, {\r\n      method: \"POST\",\r\n      headers: { \"Content-Type\": \"application/json\" },\r\n      body: JSON.stringify(body),\r\n      signal: controller.signal,\r\n    });\r\n    clearTimeout(id);\r\n    if (!resp.ok) {\r\n      const text = await resp.text().catch(() => \"\");\r\n      return { ok: false, status: resp.status, body: text };\r\n    }\r\n    const json = await resp.json().catch(() => ({}));\r\n    return { ok: true, result: json };\r\n  } catch (err: any) {\r\n    return { ok: false, error: String(err?.message ?? err) };\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,oBAAoB;AACpB,6EAA6E;AAC7E,SAAS;AACT,gDAAgD;AAChD,iGAAiG;;;;;AAEjG;;AAEA,MAAM,oBAAoB,QAAQ,GAAG,CAAC,iBAAiB,IAAI,QAAQ,GAAG,CAAC,sBAAsB,IAAI;AACjG,MAAM,oBAAoB,QAAQ,GAAG,CAAC,iBAAiB,IAAI;AAUpD,eAAe,YAAY,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC,EAAE,KAAK,EAAE,eAAe,EAAE,YAAY,IAAI,EAAY;IAC3G;;IACA,IAAI,CAAC,mBAAmB;QACtB,4DAA4D;QAC5D,QAAQ,IAAI,CAAC;IACf;IAEA,MAAM,MAAM,IAAI,IAAI,SAAS,mBAAmB,QAAQ;IACxD,MAAM,OAAO;QACX,KAAK;QACL;QACA;QACA;QACA;IACF;IAEA,IAAI;QACF,MAAM,aAAa,IAAI;QACvB,MAAM,KAAK,WAAW,IAAM,WAAW,KAAK,IAAI;QAChD,MAAM,OAAO,MAAM,IAAA,0KAAK,EAAC,KAAK;YAC5B,QAAQ;YACR,SAAS;gBAAE,gBAAgB;YAAmB;YAC9C,MAAM,KAAK,SAAS,CAAC;YACrB,QAAQ,WAAW,MAAM;QAC3B;QACA,aAAa;QACb,IAAI,CAAC,KAAK,EAAE,EAAE;YACZ,MAAM,OAAO,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,IAAM;YAC3C,OAAO;gBAAE,IAAI;gBAAO,QAAQ,KAAK,MAAM;gBAAE,MAAM;YAAK;QACtD;QACA,MAAM,OAAO,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,CAAC,CAAC;QAC9C,OAAO;YAAE,IAAI;YAAM,QAAQ;QAAK;IAClC,EAAE,OAAO,KAAU;QACjB,OAAO;YAAE,IAAI;YAAO,OAAO,OAAO,KAAK,WAAW;QAAK;IACzD;AACF","debugId":null}},
    {"offset": {"line": 200, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/socketAdapter.ts"],"sourcesContent":["// src/lib/socketAdapter.ts\r\n// Adapter to forward legacy `global.io` / `global._io` / `global.socketServer`\r\n// calls to the standalone socket server via the /emit HTTP endpoint.\r\n\r\nimport { emitToRooms } from \"@/lib/socket\";\r\n\r\ntype EmitFn = (event: string, payload?: any) => Promise<void> | void;\r\n\r\nfunction makeRoomEmitter(room: string | string[]) {\r\n  return {\r\n    emit: (event: string, payload?: any) => {\r\n      return emitToRooms({ event, payload, rooms: room });\r\n    },\r\n    // allow io.to(room).except(socketId).emit(...) pattern\r\n    except: (socketId: string) => ({\r\n      emit: (event: string, payload?: any) => {\r\n        return emitToRooms({ event, payload, rooms: room, excludeSocketId: socketId });\r\n      },\r\n    }),\r\n  };\r\n}\r\n\r\n// Single shared adapter instance\r\nconst adapter = {\r\n  /**\r\n   * io.emit(\"event\", payload)\r\n   *  -> broadcast globally\r\n   */\r\n  emit: ((event: string, payload?: any) => {\r\n    return emitToRooms({ event, payload });\r\n  }) as EmitFn,\r\n\r\n  /**\r\n   * io.to(\"room\").emit(\"event\", payload)\r\n   *  -> broadcast to specific room(s)\r\n   */\r\n  to: (room: string | string[]) => makeRoomEmitter(room),\r\n};\r\n\r\n// Attach to global only once\r\ndeclare global {\r\n  // eslint-disable-next-line no-var\r\n  var __socketAdapterInitialized: boolean | undefined;\r\n}\r\n\r\nfunction attachGlobals() {\r\n  if (global.__socketAdapterInitialized) return;\r\n  global.__socketAdapterInitialized = true;\r\n\r\n  // These are the names used in your API code:\r\n  // (global as any).io || (global as any)._io || (global as any).socketServer\r\n  const g: any = global;\r\n\r\n  if (!g.io) g.io = adapter;\r\n  if (!g._io) g._io = adapter;\r\n  if (!g.socketServer) g.socketServer = adapter;\r\n}\r\n\r\n// Run immediately on import (server-only)\r\nattachGlobals();\r\n\r\nexport { adapter as socketAdapter };\r\n"],"names":[],"mappings":"AAAA,2BAA2B;AAC3B,+EAA+E;AAC/E,qEAAqE;;;;;AAErE;;AAIA,SAAS,gBAAgB,IAAuB;IAC9C,OAAO;QACL,MAAM,CAAC,OAAe;YACpB,OAAO,IAAA,qIAAW,EAAC;gBAAE;gBAAO;gBAAS,OAAO;YAAK;QACnD;QACA,uDAAuD;QACvD,QAAQ,CAAC,WAAqB,CAAC;gBAC7B,MAAM,CAAC,OAAe;oBACpB,OAAO,IAAA,qIAAW,EAAC;wBAAE;wBAAO;wBAAS,OAAO;wBAAM,iBAAiB;oBAAS;gBAC9E;YACF,CAAC;IACH;AACF;AAEA,iCAAiC;AACjC,MAAM,UAAU;IACd;;;GAGC,GACD,MAAO,CAAC,OAAe;QACrB,OAAO,IAAA,qIAAW,EAAC;YAAE;YAAO;QAAQ;IACtC;IAEA;;;GAGC,GACD,IAAI,CAAC,OAA4B,gBAAgB;AACnD;AAQA,SAAS;IACP,IAAI,OAAO,0BAA0B,EAAE;IACvC,OAAO,0BAA0B,GAAG;IAEpC,6CAA6C;IAC7C,4EAA4E;IAC5E,MAAM,IAAS;IAEf,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG;IAClB,IAAI,CAAC,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG;IACpB,IAAI,CAAC,EAAE,YAAY,EAAE,EAAE,YAAY,GAAG;AACxC;AAEA,0CAA0C;AAC1C","debugId":null}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["// lib/prisma.ts\r\nimport { PrismaClient } from \"@prisma/client\";\r\n// near the top, before exports\r\nimport \"@/lib/socketAdapter\";\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line\r\n  var __prisma__: PrismaClient | undefined;\r\n}\r\nexport const prisma =\r\n  global.__prisma__ ??\r\n  new PrismaClient({\r\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"warn\", \"error\"] : [\"error\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.__prisma__ = prisma;\r\n"],"names":[],"mappings":"AAAA,gBAAgB;;;;;AAChB;AACA,+BAA+B;AAC/B;;;AAMO,MAAM,SACX,OAAO,UAAU,IACjB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAQ;KAAQ,GAAG;AAC7E;AAEF,wCAA2C,OAAO,UAAU,GAAG","debugId":null}},
    {"offset": {"line": 304, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/jwt.ts"],"sourcesContent":["// src/lib/jwt.ts\r\nimport jwt, { JwtPayload } from \"jsonwebtoken\";\r\n\r\nconst SECRET = process.env.JWT_SECRET;\r\nif (!SECRET) {\r\n  if (process.env.NODE_ENV === \"production\") {\r\n    throw new Error(\"JWT_SECRET environment variable must be set in production!\");\r\n  } else {\r\n    console.warn(\"[JWT] Using fallback secret for development\");\r\n  }\r\n}\r\n\r\n/**\r\n * üîê Create a short-lived temp token (email/phone verification)\r\n */\r\nexport function signTemp(payload: Record<string, any>, expiresIn: string = \"15m\"): string {\r\n  const safePayload = { ...payload };\r\n  delete safePayload.exp;\r\n  return jwt.sign(safePayload, SECRET!, { expiresIn });\r\n}\r\n\r\n/**\r\n * ‚úÖ Verify short-lived temp tokens\r\n * Returns payload object or null if invalid/expired\r\n */\r\nexport function verifyTemp(token: string): Record<string, any> | null {\r\n  try {\r\n    return jwt.verify(token, SECRET!) as Record<string, any>;\r\n  } catch (err) {\r\n    console.warn(\"[JWT] verifyTemp failed:\", (err as Error).message);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * üíæ Create a long-lived session token for logged-in users\r\n */\r\nexport function signSession(payload: Record<string, any>, expiresIn: string = \"7d\"): string {\r\n  const safePayload = { ...payload };\r\n  delete safePayload.exp;\r\n  return jwt.sign(safePayload, SECRET!, { expiresIn });\r\n}\r\n\r\n/**\r\n * üîé Verify a session token\r\n * Returns payload object or null if invalid/expired\r\n */\r\nexport function verifySession(token: string): Record<string, any> | null {\r\n  try {\r\n    return jwt.verify(token, SECRET!) as Record<string, any>;\r\n  } catch (err) {\r\n    console.warn(\"[JWT] verifySession failed:\", (err as Error).message);\r\n    return null;\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,iBAAiB;;;;;;;;;;;AACjB;;AAEA,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU;AACrC,IAAI,CAAC,QAAQ;IACX;;SAEO;QACL,QAAQ,IAAI,CAAC;IACf;AACF;AAKO,SAAS,SAAS,OAA4B,EAAE,YAAoB,KAAK;IAC9E,MAAM,cAAc;QAAE,GAAG,OAAO;IAAC;IACjC,OAAO,YAAY,GAAG;IACtB,OAAO,kJAAG,CAAC,IAAI,CAAC,aAAa,QAAS;QAAE;IAAU;AACpD;AAMO,SAAS,WAAW,KAAa;IACtC,IAAI;QACF,OAAO,kJAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAO,KAAK;QACZ,QAAQ,IAAI,CAAC,4BAA4B,AAAC,IAAc,OAAO;QAC/D,OAAO;IACT;AACF;AAKO,SAAS,YAAY,OAA4B,EAAE,YAAoB,IAAI;IAChF,MAAM,cAAc;QAAE,GAAG,OAAO;IAAC;IACjC,OAAO,YAAY,GAAG;IACtB,OAAO,kJAAG,CAAC,IAAI,CAAC,aAAa,QAAS;QAAE;IAAU;AACpD;AAMO,SAAS,cAAc,KAAa;IACzC,IAAI;QACF,OAAO,kJAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAO,KAAK;QACZ,QAAQ,IAAI,CAAC,+BAA+B,AAAC,IAAc,OAAO;QAClE,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 363, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/auth.ts"],"sourcesContent":["// src/lib/auth.ts\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { verifySession } from \"@/lib/jwt\";\r\n\r\nexport type SessionUser = {\r\n  id: string;\r\n  email?: string | null;\r\n  role: string;\r\n  organizationId?: string | null;\r\n};\r\n\r\nexport async function getSessionUser(req: Request): Promise<SessionUser | null> {\r\n  try {\r\n    // 1Ô∏è‚É£ Prefer Authorization header: \"Bearer <token>\"\r\n    let token: string | null = null;\r\n    const authHeader = req.headers.get(\"authorization\");\r\n    if (authHeader?.startsWith(\"Bearer \")) {\r\n      token = authHeader.slice(\"Bearer \".length).trim();\r\n    }\r\n\r\n    // 2Ô∏è‚É£ Fallback to cookies\r\n    if (!token) {\r\n      const cookieHeader = req.headers.get(\"cookie\") || \"\";\r\n      const cookies: Record<string, string> = Object.fromEntries(\r\n        cookieHeader\r\n          .split(\";\")\r\n          .map(c => c.trim().split(\"=\"))\r\n          .map(([k, v]) => [decodeURIComponent(k), decodeURIComponent(v)])\r\n      );\r\n      token = cookies[\"session\"] || cookies[\"token\"] || null;\r\n    }\r\n\r\n    if (!token) return null;\r\n\r\n    // 3Ô∏è‚É£ Verify token safely\r\n    const payload = verifySession(token);\r\n    if (!payload?.id) return null;\r\n\r\n    // 4Ô∏è‚É£ Fetch user from DB\r\n    const user = await prisma.user.findUnique({ where: { id: payload.id } });\r\n    if (!user) return null;\r\n\r\n    return {\r\n      id: user.id,\r\n      email: user.email ?? null,\r\n      role: user.role,\r\n      organizationId: user.organizationId,\r\n    };\r\n  } catch (err: any) {\r\n    console.warn(\"[getSessionUser] error:\", err?.message || err);\r\n    return null;\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,kBAAkB;;;;;AAClB;AACA;;;AASO,eAAe,eAAe,GAAY;IAC/C,IAAI;QACF,oDAAoD;QACpD,IAAI,QAAuB;QAC3B,MAAM,aAAa,IAAI,OAAO,CAAC,GAAG,CAAC;QACnC,IAAI,YAAY,WAAW,YAAY;YACrC,QAAQ,WAAW,KAAK,CAAC,UAAU,MAAM,EAAE,IAAI;QACjD;QAEA,0BAA0B;QAC1B,IAAI,CAAC,OAAO;YACV,MAAM,eAAe,IAAI,OAAO,CAAC,GAAG,CAAC,aAAa;YAClD,MAAM,UAAkC,OAAO,WAAW,CACxD,aACG,KAAK,CAAC,KACN,GAAG,CAAC,CAAA,IAAK,EAAE,IAAI,GAAG,KAAK,CAAC,MACxB,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,GAAK;oBAAC,mBAAmB;oBAAI,mBAAmB;iBAAG;YAEnE,QAAQ,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,QAAQ,IAAI;QACpD;QAEA,IAAI,CAAC,OAAO,OAAO;QAEnB,0BAA0B;QAC1B,MAAM,UAAU,IAAA,oIAAa,EAAC;QAC9B,IAAI,CAAC,SAAS,IAAI,OAAO;QAEzB,yBAAyB;QACzB,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE,IAAI,QAAQ,EAAE;YAAC;QAAE;QACtE,IAAI,CAAC,MAAM,OAAO;QAElB,OAAO;YACL,IAAI,KAAK,EAAE;YACX,OAAO,KAAK,KAAK,IAAI;YACrB,MAAM,KAAK,IAAI;YACf,gBAAgB,KAAK,cAAc;QACrC;IACF,EAAE,OAAO,KAAU;QACjB,QAAQ,IAAI,CAAC,2BAA2B,KAAK,WAAW;QACxD,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 415, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/app/api/chats/%5BchatId%5D/route.ts"],"sourcesContent":["// src/app/api/chats/[chatId]/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { getSessionUser } from \"@/lib/auth\";\r\nimport { cookies } from \"next/headers\";\r\nimport jwt from \"jsonwebtoken\";\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET || \"\";\r\nconst DEFAULT_PAGE_SIZE = 50;\r\n\r\n/* -----------------------------------------------------------\r\n   Safe JSON parser\r\n----------------------------------------------------------- */\r\nasync function safeJson(req: Request) {\r\n  try {\r\n    return await req.json();\r\n  } catch {\r\n    return {};\r\n  }\r\n}\r\n\r\n/* -----------------------------------------------------------\r\n   Session Resolution\r\n----------------------------------------------------------- */\r\nasync function resolveSessionUser(req: Request) {\r\n  // try next-auth\r\n  try {\r\n    const u = await getSessionUser(req);\r\n    if (u?.id) return u;\r\n  } catch {}\r\n\r\n  // bearer token\r\n  try {\r\n    const auth = req.headers.get(\"authorization\") ?? req.headers.get(\"Authorization\");\r\n    if (auth?.toLowerCase().startsWith(\"bearer \")) {\r\n      const token = auth.slice(7).trim();\r\n      if (token && JWT_SECRET) {\r\n        const payload = jwt.verify(token, JWT_SECRET) as any;\r\n        if (payload?.id) return payload;\r\n      }\r\n    }\r\n  } catch {}\r\n\r\n  // cookie\r\n  try {\r\n    const store = await cookies();\r\n    const token = store.get(\"session\")?.value;\r\n    if (token && JWT_SECRET) {\r\n      const payload = jwt.verify(token, JWT_SECRET) as any;\r\n      if (payload?.id) return payload;\r\n    }\r\n  } catch {}\r\n\r\n  return null;\r\n}\r\n\r\n/* -----------------------------------------------------------\r\n   Authorization helper (same rules as chats/route)\r\n   - ADMIN ‚Üí allowed\r\n   - else must be chatMember OR (if team chat) teamMember\r\n   - also must belong to same organization as chat\r\n----------------------------------------------------------- */\r\nasync function authorizeForChat(userId: string, userRole: string | null, chatId: string) {\r\n  if (userRole === \"ADMIN\") return true;\r\n\r\n  const chat = await prisma.chat.findUnique({\r\n    where: { id: chatId },\r\n    select: { organizationId: true, teamId: true },\r\n  });\r\n\r\n  if (!chat) return false;\r\n\r\n  // Must belong to same org\r\n  const user = await prisma.user.findUnique({\r\n    where: { id: userId },\r\n    select: { organizationId: true },\r\n  });\r\n  if (!user || user.organizationId !== chat.organizationId) return false;\r\n\r\n  // ChatMember?\r\n  const member = await prisma.chatMember.findFirst({\r\n    where: { chatId, userId },\r\n    select: { id: true },\r\n  });\r\n  if (member) return true;\r\n\r\n  // TeamMember (if team chat)\r\n  if (chat.teamId) {\r\n    const teamMember = await prisma.teamMember.findFirst({\r\n      where: { teamId: chat.teamId, userId },\r\n      select: { id: true },\r\n    });\r\n    if (teamMember) return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/* -----------------------------------------------------------\r\n   Mark a chat as read for a user (upsert ChatLastRead)\r\n----------------------------------------------------------- */\r\nasync function markChatRead(chatId: string, userId: string) {\r\n  try {\r\n    if (!(prisma as any).chatLastRead) return;\r\n    await (prisma as any).chatLastRead.upsert({\r\n      where: { chatId_userId: { chatId, userId } },\r\n      create: { chatId, userId, lastReadAt: new Date() },\r\n      update: { lastReadAt: new Date() },\r\n    });\r\n  } catch (e) {\r\n    // non-fatal\r\n    console.warn(\"[chat] markChatRead failed:\", e);\r\n  }\r\n}\r\n\r\n/* -----------------------------------------------------------\r\n   GET: fetch messages (with pagination)\r\n   - also marks chat as read for the requesting user\r\n   NOTE: ctx.params is a Promise in App Router ‚Äî await it.\r\n----------------------------------------------------------- */\r\nexport async function GET(req: Request, ctx: { params: Promise<{ chatId?: string }> }) {\r\n  try {\r\n    const params = await ctx.params;\r\n    const chatId = params?.chatId;\r\n    if (!chatId) return NextResponse.json({ ok: false, message: \"chatId required\" }, { status: 400 });\r\n\r\n    const session = await resolveSessionUser(req);\r\n    if (!session) return NextResponse.json({ ok: false, message: \"Unauthorized\" }, { status: 401 });\r\n\r\n    const userId = String(session.id);\r\n    const allowed = await authorizeForChat(userId, session.role ?? null, chatId);\r\n    if (!allowed) return NextResponse.json({ ok: false, message: \"Forbidden\" }, { status: 403 });\r\n\r\n    // pagination\r\n    const url = new URL(req.url);\r\n    let limit = Number(url.searchParams.get(\"limit\"));\r\n    if (!limit || limit <= 0) limit = DEFAULT_PAGE_SIZE;\r\n    if (limit > 200) limit = 200;\r\n\r\n    const before = url.searchParams.get(\"before\");\r\n\r\n    const where: any = { chatId };\r\n    if (before) {\r\n      const date = new Date(before);\r\n      if (!isNaN(date.getTime())) where.createdAt = { lt: date };\r\n    }\r\n\r\n    const rows = await prisma.chatMessage.findMany({\r\n      where,\r\n      orderBy: { createdAt: \"desc\" },\r\n      take: limit,\r\n      include: { sender: { select: { id: true, name: true, email: true } } },\r\n    });\r\n\r\n    // Reverse so the earliest message (of this page) is first\r\n    const messages = rows\r\n      .map((r) => ({\r\n        id: r.id,\r\n        chatId: r.chatId,\r\n        content: r.content,\r\n        metadata: r.metadata ?? null,\r\n        externalId: r.externalId ?? null,\r\n        createdAt: r.createdAt?.toISOString?.() ?? null,\r\n        sender: r.sender ? { id: r.sender.id, name: r.sender.name, email: r.sender.email } : null,\r\n      }))\r\n      .reverse();\r\n\r\n    // Mark chat as read for this user (best-effort, non-blocking)\r\n    (async () => {\r\n      await markChatRead(chatId, userId);\r\n    })();\r\n\r\n    return NextResponse.json({ ok: true, messages }, { status: 200 });\r\n  } catch (err) {\r\n    console.error(\"GET /api/chats/[chatId] error:\", err);\r\n    return NextResponse.json({ ok: false, message: \"Internal Server Error\" }, { status: 500 });\r\n  }\r\n}\r\n\r\n/* -----------------------------------------------------------\r\n   POST: create/send new message\r\n   - enforces authorization via authorizeForChat\r\n   - updates chat.lastMessageAt\r\n   - upserts ChatLastRead for sender\r\n   - emits \"chat:message\" to chat:<chatId> & per-user rooms\r\n   NOTE: ctx.params is a Promise in App Router ‚Äî await it.\r\n----------------------------------------------------------- */\r\nexport async function POST(req: Request, ctx: { params: Promise<{ chatId?: string }> }) {\r\n  try {\r\n    const params = await ctx.params;\r\n    const chatId = params?.chatId;\r\n    if (!chatId) return NextResponse.json({ ok: false, message: \"chatId required\" }, { status: 400 });\r\n\r\n    const session = await resolveSessionUser(req);\r\n    if (!session) return NextResponse.json({ ok: false, message: \"Unauthorized\" }, { status: 401 });\r\n\r\n    const userId = String(session.id);\r\n    const userRole = session.role ?? null;\r\n    const allowed = await authorizeForChat(userId, userRole, chatId);\r\n    if (!allowed) return NextResponse.json({ ok: false, message: \"Forbidden\" }, { status: 403 });\r\n\r\n    const body = await safeJson(req);\r\n    const content = typeof body.content === \"string\" ? body.content.trim() : \"\";\r\n    if (!content) return NextResponse.json({ ok: false, message: \"Message content required\" }, { status: 400 });\r\n\r\n    const metadata = typeof body.metadata === \"object\" ? body.metadata : undefined;\r\n    const externalId = typeof body.externalId === \"string\" ? body.externalId : undefined;\r\n\r\n    // Persist message and update chat metadata atomically\r\n    const created = await prisma.$transaction(async (tx) => {\r\n      const m = await tx.chatMessage.create({\r\n        data: { chatId, senderId: userId, content, metadata, externalId },\r\n        include: { sender: { select: { id: true, name: true, email: true } } },\r\n      });\r\n\r\n      await tx.chat.update({ where: { id: chatId }, data: { lastMessageAt: new Date() } });\r\n\r\n      // upsert ChatLastRead for sender (so sender doesn't see their own message as unread)\r\n      try {\r\n        if ((prisma as any).chatLastRead) {\r\n          await (tx as any).chatLastRead.upsert({\r\n            where: { chatId_userId: { chatId, userId } },\r\n            create: { chatId, userId, lastReadAt: new Date() },\r\n            update: { lastReadAt: new Date() },\r\n          });\r\n        }\r\n      } catch (e) {\r\n        // ignore\r\n      }\r\n\r\n      return m;\r\n    });\r\n\r\n    // Build payload\r\n    const payload = {\r\n      chatId,\r\n      message: {\r\n        id: created.id,\r\n        content: created.content,\r\n        metadata: created.metadata ?? null,\r\n        externalId: created.externalId ?? null,\r\n        createdAt: created.createdAt?.toISOString?.() ?? null,\r\n        sender: created.sender ? { id: created.sender.id, name: created.sender.name, email: created.sender.email } : null,\r\n      },\r\n    };\r\n\r\n    // Broadcast via socket.io (best-effort). Use standard rooms:\r\n    // - chat:<chatId> (room for chat)\r\n    // - user:<userId> (personal rooms) ‚Äî notify all current chat members (query required)\r\n    (async () => {\r\n      try {\r\n        const io = (globalThis as any).io || (globalThis as any)._io || (globalThis as any).socketServer;\r\n        if (!io) return;\r\n\r\n        // emit to chat room\r\n        if (typeof io.to === \"function\") {\r\n          try {\r\n            io.to(`chat:${chatId}`).emit(\"chat:message\", payload);\r\n          } catch (e) {\r\n            // fallback\r\n            try { io.emit(\"chat:message\", payload); } catch {}\r\n          }\r\n        }\r\n\r\n        // notify each member individually (helps deliver desktop/notification flows)\r\n        const chatMembers = await prisma.chatMember.findMany({\r\n          where: { chatId },\r\n          select: { userId: true },\r\n        });\r\n\r\n        for (const cm of chatMembers) {\r\n          try {\r\n            if (typeof io.to === \"function\") io.to(`user:${cm.userId}`).emit(\"chat:message\", payload);\r\n            else if (typeof io.emit === \"function\") io.emit(\"chat:message\", payload);\r\n          } catch {}\r\n        }\r\n\r\n        // Also emit to org room (optional)\r\n        try {\r\n          const chat = await prisma.chat.findUnique({ where: { id: chatId }, select: { organizationId: true } });\r\n          if (chat?.organizationId) {\r\n            try {\r\n              if (typeof io.to === \"function\") io.to(`org:${chat.organizationId}`).emit(\"chat:message\", payload);\r\n            } catch {}\r\n          }\r\n        } catch {}\r\n      } catch (err) {\r\n        console.warn(\"Socket broadcast failed (ignored):\", err);\r\n      }\r\n    })();\r\n\r\n    return NextResponse.json({ ok: true, message: payload.message }, { status: 201 });\r\n  } catch (err) {\r\n    console.error(\"POST /api/chats/[chatId] error:\", err);\r\n    return NextResponse.json({ ok: false, message: \"Internal Server Error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}
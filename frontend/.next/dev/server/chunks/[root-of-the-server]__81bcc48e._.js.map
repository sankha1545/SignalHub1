{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/socket.ts"],"sourcesContent":["// src/lib/socket.ts\r\n// Small helper to call the socket server's /emit endpoint from backend code.\r\n// Usage:\r\n//   import { emitToRooms } from \"@/lib/socket\";\r\n//   await emitToRooms({ event: \"chat:created\", rooms: [\"user:123\",\"org:abc\"], payload: {...} });\r\n\r\nimport fetch from \"node-fetch\";\r\n\r\nconst SOCKET_SERVER_URL = process.env.SOCKET_SERVER_URL || process.env.NEXT_PUBLIC_SOCKET_URL || \"http://localhost:4001\";\r\nconst SOCKET_SERVER_KEY = process.env.SOCKET_SERVER_KEY || \"\";\r\n\r\ntype EmitArgs = {\r\n  event: string;\r\n  payload?: any;\r\n  rooms?: string[] | string;\r\n  excludeSocketId?: string;\r\n  timeoutMs?: number;\r\n};\r\n\r\nexport async function emitToRooms({ event, payload = {}, rooms, excludeSocketId, timeoutMs = 2000 }: EmitArgs) {\r\n  if (!SOCKET_SERVER_URL) return { ok: false, error: \"no socket server url\" };\r\n  if (!SOCKET_SERVER_KEY) {\r\n    // still allow if no key supplied (not recommended for prod)\r\n    console.warn(\"socket: no SOCKET_SERVER_KEY configured ‚Äî /emit endpoint not protected\");\r\n  }\r\n\r\n  const url = new URL(\"/emit\", SOCKET_SERVER_URL).toString();\r\n  const body = {\r\n    key: SOCKET_SERVER_KEY,\r\n    rooms,\r\n    event,\r\n    payload,\r\n    excludeSocketId,\r\n  };\r\n\r\n  try {\r\n    const controller = new AbortController();\r\n    const id = setTimeout(() => controller.abort(), timeoutMs);\r\n    const resp = await fetch(url, {\r\n      method: \"POST\",\r\n      headers: { \"Content-Type\": \"application/json\" },\r\n      body: JSON.stringify(body),\r\n      signal: controller.signal,\r\n    });\r\n    clearTimeout(id);\r\n    if (!resp.ok) {\r\n      const text = await resp.text().catch(() => \"\");\r\n      return { ok: false, status: resp.status, body: text };\r\n    }\r\n    const json = await resp.json().catch(() => ({}));\r\n    return { ok: true, result: json };\r\n  } catch (err: any) {\r\n    return { ok: false, error: String(err?.message ?? err) };\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,oBAAoB;AACpB,6EAA6E;AAC7E,SAAS;AACT,gDAAgD;AAChD,iGAAiG;;;;;AAEjG;;AAEA,MAAM,oBAAoB,QAAQ,GAAG,CAAC,iBAAiB,IAAI,QAAQ,GAAG,CAAC,sBAAsB,IAAI;AACjG,MAAM,oBAAoB,QAAQ,GAAG,CAAC,iBAAiB,IAAI;AAUpD,eAAe,YAAY,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC,EAAE,KAAK,EAAE,eAAe,EAAE,YAAY,IAAI,EAAY;IAC3G;;IACA,IAAI,CAAC,mBAAmB;QACtB,4DAA4D;QAC5D,QAAQ,IAAI,CAAC;IACf;IAEA,MAAM,MAAM,IAAI,IAAI,SAAS,mBAAmB,QAAQ;IACxD,MAAM,OAAO;QACX,KAAK;QACL;QACA;QACA;QACA;IACF;IAEA,IAAI;QACF,MAAM,aAAa,IAAI;QACvB,MAAM,KAAK,WAAW,IAAM,WAAW,KAAK,IAAI;QAChD,MAAM,OAAO,MAAM,IAAA,0KAAK,EAAC,KAAK;YAC5B,QAAQ;YACR,SAAS;gBAAE,gBAAgB;YAAmB;YAC9C,MAAM,KAAK,SAAS,CAAC;YACrB,QAAQ,WAAW,MAAM;QAC3B;QACA,aAAa;QACb,IAAI,CAAC,KAAK,EAAE,EAAE;YACZ,MAAM,OAAO,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,IAAM;YAC3C,OAAO;gBAAE,IAAI;gBAAO,QAAQ,KAAK,MAAM;gBAAE,MAAM;YAAK;QACtD;QACA,MAAM,OAAO,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,CAAC,CAAC;QAC9C,OAAO;YAAE,IAAI;YAAM,QAAQ;QAAK;IAClC,EAAE,OAAO,KAAU;QACjB,OAAO;YAAE,IAAI;YAAO,OAAO,OAAO,KAAK,WAAW;QAAK;IACzD;AACF","debugId":null}},
    {"offset": {"line": 200, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/socketAdapter.ts"],"sourcesContent":["// src/lib/socketAdapter.ts\r\n// Adapter to forward legacy `global.io` / `global._io` / `global.socketServer`\r\n// calls to the standalone socket server via the /emit HTTP endpoint.\r\n\r\nimport { emitToRooms } from \"@/lib/socket\";\r\n\r\ntype EmitFn = (event: string, payload?: any) => Promise<void> | void;\r\n\r\nfunction makeRoomEmitter(room: string | string[]) {\r\n  return {\r\n    emit: (event: string, payload?: any) => {\r\n      return emitToRooms({ event, payload, rooms: room });\r\n    },\r\n    // allow io.to(room).except(socketId).emit(...) pattern\r\n    except: (socketId: string) => ({\r\n      emit: (event: string, payload?: any) => {\r\n        return emitToRooms({ event, payload, rooms: room, excludeSocketId: socketId });\r\n      },\r\n    }),\r\n  };\r\n}\r\n\r\n// Single shared adapter instance\r\nconst adapter = {\r\n  /**\r\n   * io.emit(\"event\", payload)\r\n   *  -> broadcast globally\r\n   */\r\n  emit: ((event: string, payload?: any) => {\r\n    return emitToRooms({ event, payload });\r\n  }) as EmitFn,\r\n\r\n  /**\r\n   * io.to(\"room\").emit(\"event\", payload)\r\n   *  -> broadcast to specific room(s)\r\n   */\r\n  to: (room: string | string[]) => makeRoomEmitter(room),\r\n};\r\n\r\n// Attach to global only once\r\ndeclare global {\r\n  // eslint-disable-next-line no-var\r\n  var __socketAdapterInitialized: boolean | undefined;\r\n}\r\n\r\nfunction attachGlobals() {\r\n  if (global.__socketAdapterInitialized) return;\r\n  global.__socketAdapterInitialized = true;\r\n\r\n  // These are the names used in your API code:\r\n  // (global as any).io || (global as any)._io || (global as any).socketServer\r\n  const g: any = global;\r\n\r\n  if (!g.io) g.io = adapter;\r\n  if (!g._io) g._io = adapter;\r\n  if (!g.socketServer) g.socketServer = adapter;\r\n}\r\n\r\n// Run immediately on import (server-only)\r\nattachGlobals();\r\n\r\nexport { adapter as socketAdapter };\r\n"],"names":[],"mappings":"AAAA,2BAA2B;AAC3B,+EAA+E;AAC/E,qEAAqE;;;;;AAErE;;AAIA,SAAS,gBAAgB,IAAuB;IAC9C,OAAO;QACL,MAAM,CAAC,OAAe;YACpB,OAAO,IAAA,qIAAW,EAAC;gBAAE;gBAAO;gBAAS,OAAO;YAAK;QACnD;QACA,uDAAuD;QACvD,QAAQ,CAAC,WAAqB,CAAC;gBAC7B,MAAM,CAAC,OAAe;oBACpB,OAAO,IAAA,qIAAW,EAAC;wBAAE;wBAAO;wBAAS,OAAO;wBAAM,iBAAiB;oBAAS;gBAC9E;YACF,CAAC;IACH;AACF;AAEA,iCAAiC;AACjC,MAAM,UAAU;IACd;;;GAGC,GACD,MAAO,CAAC,OAAe;QACrB,OAAO,IAAA,qIAAW,EAAC;YAAE;YAAO;QAAQ;IACtC;IAEA;;;GAGC,GACD,IAAI,CAAC,OAA4B,gBAAgB;AACnD;AAQA,SAAS;IACP,IAAI,OAAO,0BAA0B,EAAE;IACvC,OAAO,0BAA0B,GAAG;IAEpC,6CAA6C;IAC7C,4EAA4E;IAC5E,MAAM,IAAS;IAEf,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG;IAClB,IAAI,CAAC,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG;IACpB,IAAI,CAAC,EAAE,YAAY,EAAE,EAAE,YAAY,GAAG;AACxC;AAEA,0CAA0C;AAC1C","debugId":null}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["// lib/prisma.ts\r\nimport { PrismaClient } from \"@prisma/client\";\r\n// near the top, before exports\r\nimport \"@/lib/socketAdapter\";\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line\r\n  var __prisma__: PrismaClient | undefined;\r\n}\r\nexport const prisma =\r\n  global.__prisma__ ??\r\n  new PrismaClient({\r\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"warn\", \"error\"] : [\"error\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.__prisma__ = prisma;\r\n"],"names":[],"mappings":"AAAA,gBAAgB;;;;;AAChB;AACA,+BAA+B;AAC/B;;;AAMO,MAAM,SACX,OAAO,UAAU,IACjB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAQ;KAAQ,GAAG;AAC7E;AAEF,wCAA2C,OAAO,UAAU,GAAG","debugId":null}},
    {"offset": {"line": 304, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/jwt.ts"],"sourcesContent":["// src/lib/jwt.ts\r\nimport jwt, { JwtPayload } from \"jsonwebtoken\";\r\n\r\nconst SECRET = process.env.JWT_SECRET;\r\nif (!SECRET) {\r\n  if (process.env.NODE_ENV === \"production\") {\r\n    throw new Error(\"JWT_SECRET environment variable must be set in production!\");\r\n  } else {\r\n    console.warn(\"[JWT] Using fallback secret for development\");\r\n  }\r\n}\r\n\r\n/**\r\n * üîê Create a short-lived temp token (email/phone verification)\r\n */\r\nexport function signTemp(payload: Record<string, any>, expiresIn: string = \"15m\"): string {\r\n  const safePayload = { ...payload };\r\n  delete safePayload.exp;\r\n  return jwt.sign(safePayload, SECRET!, { expiresIn });\r\n}\r\n\r\n/**\r\n * ‚úÖ Verify short-lived temp tokens\r\n * Returns payload object or null if invalid/expired\r\n */\r\nexport function verifyTemp(token: string): Record<string, any> | null {\r\n  try {\r\n    return jwt.verify(token, SECRET!) as Record<string, any>;\r\n  } catch (err) {\r\n    console.warn(\"[JWT] verifyTemp failed:\", (err as Error).message);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * üíæ Create a long-lived session token for logged-in users\r\n */\r\nexport function signSession(payload: Record<string, any>, expiresIn: string = \"7d\"): string {\r\n  const safePayload = { ...payload };\r\n  delete safePayload.exp;\r\n  return jwt.sign(safePayload, SECRET!, { expiresIn });\r\n}\r\n\r\n/**\r\n * üîé Verify a session token\r\n * Returns payload object or null if invalid/expired\r\n */\r\nexport function verifySession(token: string): Record<string, any> | null {\r\n  try {\r\n    return jwt.verify(token, SECRET!) as Record<string, any>;\r\n  } catch (err) {\r\n    console.warn(\"[JWT] verifySession failed:\", (err as Error).message);\r\n    return null;\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,iBAAiB;;;;;;;;;;;AACjB;;AAEA,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU;AACrC,IAAI,CAAC,QAAQ;IACX;;SAEO;QACL,QAAQ,IAAI,CAAC;IACf;AACF;AAKO,SAAS,SAAS,OAA4B,EAAE,YAAoB,KAAK;IAC9E,MAAM,cAAc;QAAE,GAAG,OAAO;IAAC;IACjC,OAAO,YAAY,GAAG;IACtB,OAAO,kJAAG,CAAC,IAAI,CAAC,aAAa,QAAS;QAAE;IAAU;AACpD;AAMO,SAAS,WAAW,KAAa;IACtC,IAAI;QACF,OAAO,kJAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAO,KAAK;QACZ,QAAQ,IAAI,CAAC,4BAA4B,AAAC,IAAc,OAAO;QAC/D,OAAO;IACT;AACF;AAKO,SAAS,YAAY,OAA4B,EAAE,YAAoB,IAAI;IAChF,MAAM,cAAc;QAAE,GAAG,OAAO;IAAC;IACjC,OAAO,YAAY,GAAG;IACtB,OAAO,kJAAG,CAAC,IAAI,CAAC,aAAa,QAAS;QAAE;IAAU;AACpD;AAMO,SAAS,cAAc,KAAa;IACzC,IAAI;QACF,OAAO,kJAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAO,KAAK;QACZ,QAAQ,IAAI,CAAC,+BAA+B,AAAC,IAAc,OAAO;QAClE,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 363, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/auth.ts"],"sourcesContent":["// src/lib/auth.ts\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { verifySession } from \"@/lib/jwt\";\r\n\r\nexport type SessionUser = {\r\n  id: string;\r\n  email?: string | null;\r\n  role: string;\r\n  organizationId?: string | null;\r\n};\r\n\r\nexport async function getSessionUser(req: Request): Promise<SessionUser | null> {\r\n  try {\r\n    // 1Ô∏è‚É£ Prefer Authorization header: \"Bearer <token>\"\r\n    let token: string | null = null;\r\n    const authHeader = req.headers.get(\"authorization\");\r\n    if (authHeader?.startsWith(\"Bearer \")) {\r\n      token = authHeader.slice(\"Bearer \".length).trim();\r\n    }\r\n\r\n    // 2Ô∏è‚É£ Fallback to cookies\r\n    if (!token) {\r\n      const cookieHeader = req.headers.get(\"cookie\") || \"\";\r\n      const cookies: Record<string, string> = Object.fromEntries(\r\n        cookieHeader\r\n          .split(\";\")\r\n          .map(c => c.trim().split(\"=\"))\r\n          .map(([k, v]) => [decodeURIComponent(k), decodeURIComponent(v)])\r\n      );\r\n      token = cookies[\"session\"] || cookies[\"token\"] || null;\r\n    }\r\n\r\n    if (!token) return null;\r\n\r\n    // 3Ô∏è‚É£ Verify token safely\r\n    const payload = verifySession(token);\r\n    if (!payload?.id) return null;\r\n\r\n    // 4Ô∏è‚É£ Fetch user from DB\r\n    const user = await prisma.user.findUnique({ where: { id: payload.id } });\r\n    if (!user) return null;\r\n\r\n    return {\r\n      id: user.id,\r\n      email: user.email ?? null,\r\n      role: user.role,\r\n      organizationId: user.organizationId,\r\n    };\r\n  } catch (err: any) {\r\n    console.warn(\"[getSessionUser] error:\", err?.message || err);\r\n    return null;\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,kBAAkB;;;;;AAClB;AACA;;;AASO,eAAe,eAAe,GAAY;IAC/C,IAAI;QACF,oDAAoD;QACpD,IAAI,QAAuB;QAC3B,MAAM,aAAa,IAAI,OAAO,CAAC,GAAG,CAAC;QACnC,IAAI,YAAY,WAAW,YAAY;YACrC,QAAQ,WAAW,KAAK,CAAC,UAAU,MAAM,EAAE,IAAI;QACjD;QAEA,0BAA0B;QAC1B,IAAI,CAAC,OAAO;YACV,MAAM,eAAe,IAAI,OAAO,CAAC,GAAG,CAAC,aAAa;YAClD,MAAM,UAAkC,OAAO,WAAW,CACxD,aACG,KAAK,CAAC,KACN,GAAG,CAAC,CAAA,IAAK,EAAE,IAAI,GAAG,KAAK,CAAC,MACxB,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,GAAK;oBAAC,mBAAmB;oBAAI,mBAAmB;iBAAG;YAEnE,QAAQ,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,QAAQ,IAAI;QACpD;QAEA,IAAI,CAAC,OAAO,OAAO;QAEnB,0BAA0B;QAC1B,MAAM,UAAU,IAAA,oIAAa,EAAC;QAC9B,IAAI,CAAC,SAAS,IAAI,OAAO;QAEzB,yBAAyB;QACzB,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE,IAAI,QAAQ,EAAE;YAAC;QAAE;QACtE,IAAI,CAAC,MAAM,OAAO;QAElB,OAAO;YACL,IAAI,KAAK,EAAE;YACX,OAAO,KAAK,KAAK,IAAI;YACrB,MAAM,KAAK,IAAI;YACf,gBAAgB,KAAK,cAAc;QACrC;IACF,EAAE,OAAO,KAAU;QACjB,QAAQ,IAAI,CAAC,2BAA2B,KAAK,WAAW;QACxD,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 415, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/app/api/chats/route.ts"],"sourcesContent":["// src/app/api/chats/route.ts\r\n\r\nimport { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { getSessionUser } from \"@/lib/auth\";\r\nimport { cookies } from \"next/headers\";\r\nimport jwt from \"jsonwebtoken\";\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET || \"\";\r\n\r\n/* -------------------------------------------------------\r\n   Helpers\r\n------------------------------------------------------- */\r\n\r\nasync function safeJson(req: Request) {\r\n  try {\r\n    return await req.json();\r\n  } catch {\r\n    return {};\r\n  }\r\n}\r\n\r\n/**\r\n * Resolve logged-in user from:\r\n * 1. next-auth helper\r\n * 2. Authorization header\r\n * 3. Session cookie\r\n */\r\nasync function resolveSessionUser(req: Request) {\r\n  // #1 next-auth\r\n  try {\r\n    const u = await getSessionUser(req);\r\n    if (u?.id) return u;\r\n  } catch {}\r\n\r\n  // #2 bearer\r\n  try {\r\n    const auth =\r\n      req.headers.get(\"authorization\") ??\r\n      req.headers.get(\"Authorization\");\r\n    if (auth?.toLowerCase().startsWith(\"bearer \")) {\r\n      const token = auth.slice(7).trim();\r\n      if (token && JWT_SECRET) {\r\n        const payload = jwt.verify(token, JWT_SECRET) as any;\r\n        if (payload?.id) return payload;\r\n      }\r\n    }\r\n  } catch {}\r\n\r\n  // #3 cookie\r\n  try {\r\n    const store = await cookies();\r\n    const token = store.get(\"session\")?.value;\r\n    if (token && JWT_SECRET) {\r\n      const payload = jwt.verify(token, JWT_SECRET) as any;\r\n      if (payload?.id) return payload;\r\n    }\r\n  } catch {}\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Authorize that user can access a team.\r\n * ADMIN ‚Üí always pass\r\n * Manager or Member of team ‚Üí pass\r\n */\r\nasync function authorizeTeamAccess(\r\n  userId: string,\r\n  userRole: string | null,\r\n  teamId: string\r\n) {\r\n  if (userRole === \"ADMIN\") return true;\r\n\r\n  const team = await prisma.team.findUnique({\r\n    where: { id: teamId },\r\n    select: { managerId: true },\r\n  });\r\n\r\n  if (!team) return false;\r\n\r\n  // Is manager?\r\n  if (team.managerId === userId) return true;\r\n\r\n  // Is team member?\r\n  const member = await prisma.teamMember.findFirst({\r\n    where: { teamId, userId },\r\n    select: { id: true },\r\n  });\r\n\r\n  return !!member;\r\n}\r\n\r\n/**\r\n * Normalize a chat for frontend use.\r\n *\r\n * NEW BEHAVIOUR:\r\n * - For DIRECT chats (or 2-member chats), we derive the `name` as:\r\n *     \"other participant's name/email\" for the given currentUserId.\r\n *   This gives you the classic DM UX: in my inbox I see *your* name,\r\n *   in your inbox you see *my* name.\r\n *\r\n * For TEAM chats:\r\n * - We keep the existing behavior: chat.name or `Team: {team.name}`.\r\n *\r\n * Also:\r\n * - Hides admin ChatMember rows when chat.type is TEAM so admin does not\r\n *   appear in the member list (existing behavior preserved).\r\n */\r\nfunction normalizeChat(chat: any, currentUserId?: string | null) {\r\n  const type = String(chat.type || \"\").toUpperCase();\r\n  const isTeam = type === \"TEAM\";\r\n\r\n  let name: string;\r\n\r\n  if (isTeam) {\r\n    // TEAM CHAT: keep original behavior\r\n    name =\r\n      chat.name ??\r\n      (chat.team ? `Team: ${chat.team.name}` : \"Chat\");\r\n  } else {\r\n    // DIRECT / PRIVATE / OTHERS\r\n    // Base name (if any explicit name)\r\n    name = chat.name ?? \"Chat\";\r\n\r\n    // If we know who is asking (currentUserId) and we have members, derive\r\n    // a more user-friendly title as \"other participant's name/email\".\r\n    if (currentUserId && Array.isArray(chat.members)) {\r\n      const others = chat.members.filter(\r\n        (m: any) =>\r\n          m?.user?.id &&\r\n          String(m.user.id) !== String(currentUserId)\r\n      );\r\n      const primaryOther = others[0]?.user;\r\n\r\n      if (primaryOther) {\r\n        name =\r\n          primaryOther.name ||\r\n          primaryOther.email ||\r\n          name; // fallback to existing name if nothing\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    id: chat.id,\r\n    name,\r\n    type: chat.type,\r\n    teamId: chat.teamId ?? null,\r\n    createdBy: chat.createdBy\r\n      ? { id: chat.createdBy.id, name: chat.createdBy.name }\r\n      : null,\r\n    members:\r\n      (chat.members ?? [])\r\n        .filter((m: any) => {\r\n          // For team chats, do not expose ChatMember rows with role ADMIN\r\n          // (these are implicit admin access)\r\n          if (\r\n            isTeam &&\r\n            String(m.role).toUpperCase() === \"ADMIN\"\r\n          )\r\n            return false;\r\n          return !!(m.user && m.user.id);\r\n        })\r\n        .map((m: any) => ({\r\n          id: m.user.id,\r\n          name: m.user.name,\r\n          email: m.user.email,\r\n          role: m.role,\r\n        })) ?? [],\r\n    lastMessageAt:\r\n      chat.lastMessageAt?.toISOString?.() ?? null,\r\n    createdAt: chat.createdAt?.toISOString?.() ?? null,\r\n  };\r\n}\r\n\r\n/* -------------------------------------------------------\r\n   GET /api/chats\r\n   - Without query ‚Üí get all chats user is a member of (or org/team chats for admin)\r\n   - With ?teamId= ‚Üí get team chat (0 or 1)\r\n------------------------------------------------------- */\r\n\r\nexport async function GET(req: Request) {\r\n  try {\r\n    const session = await resolveSessionUser(req);\r\n    if (!session) {\r\n      return NextResponse.json(\r\n        { ok: false, error: \"Unauthorized\", chats: [] },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    const userId = String(session.id);\r\n    const userRole = session.role ?? null;\r\n    const orgId = session.organizationId ?? null;\r\n\r\n    const url = new URL(req.url);\r\n    const teamId = url.searchParams.get(\"teamId\");\r\n\r\n    /* ----------------------------------------------\r\n       TEAM CHAT MODE\r\n    ---------------------------------------------- */\r\n    if (teamId) {\r\n      const chat = await prisma.chat.findFirst({\r\n        where: { teamId },\r\n        include: {\r\n          members: {\r\n            include: {\r\n              user: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  email: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n          team: { select: { id: true, name: true } },\r\n          createdBy: {\r\n            select: { id: true, name: true },\r\n          },\r\n        },\r\n      });\r\n\r\n      // If not found, return null\r\n      if (!chat) {\r\n        return NextResponse.json(\r\n          { ok: true, chat: null },\r\n          { status: 200 }\r\n        );\r\n      }\r\n\r\n      // Authorization: admins can view; others must be team members or manager\r\n      const allowed =\r\n        userRole === \"ADMIN\" ||\r\n        (await authorizeTeamAccess(\r\n          userId,\r\n          userRole,\r\n          teamId\r\n        ));\r\n      if (!allowed) {\r\n        return NextResponse.json(\r\n          { ok: false, error: \"Forbidden\", chat: null },\r\n          { status: 403 }\r\n        );\r\n      }\r\n\r\n      return NextResponse.json(\r\n        { ok: true, chat: normalizeChat(chat, userId) },\r\n        { status: 200 }\r\n      );\r\n    }\r\n\r\n    /* ----------------------------------------------\r\n       ALL CHATS FOR THIS USER\r\n    ---------------------------------------------- */\r\n\r\n    if (userRole === \"ADMIN\") {\r\n      // Admin: return all TEAM chats in org + any DIRECT/PRIVATE chats where admin is a member\r\n      if (!orgId) {\r\n        return NextResponse.json(\r\n          { ok: true, chats: [] },\r\n          { status: 200 }\r\n        );\r\n      }\r\n\r\n      // fetch team chats in org\r\n      const teamChats = await prisma.chat.findMany({\r\n        where: { organizationId: orgId, type: \"TEAM\" },\r\n        include: {\r\n          members: {\r\n            include: {\r\n              user: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  email: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n          team: { select: { id: true, name: true } },\r\n          createdBy: {\r\n            select: { id: true, name: true },\r\n          },\r\n        },\r\n        orderBy: { lastMessageAt: \"desc\" },\r\n      });\r\n\r\n      // fetch direct/private chats where admin is a member\r\n      const directMembership =\r\n        await prisma.chatMember.findMany({\r\n          where: { userId },\r\n          select: { chatId: true },\r\n        });\r\n      const directChatIds = directMembership.map(\r\n        (m) => m.chatId\r\n      );\r\n\r\n      const directChats =\r\n        directChatIds.length > 0\r\n          ? await prisma.chat.findMany({\r\n              where: { id: { in: directChatIds } },\r\n              include: {\r\n                members: {\r\n                  include: {\r\n                    user: {\r\n                      select: {\r\n                        id: true,\r\n                        name: true,\r\n                        email: true,\r\n                      },\r\n                    },\r\n                  },\r\n                },\r\n                team: {\r\n                  select: { id: true, name: true },\r\n                },\r\n                createdBy: {\r\n                  select: { id: true, name: true },\r\n                },\r\n              },\r\n              orderBy: { lastMessageAt: \"desc\" },\r\n            })\r\n          : [];\r\n\r\n      // merge and normalize (teamChats first)\r\n      const merged = [...teamChats, ...directChats].map(\r\n        (c) => normalizeChat(c, userId)\r\n      );\r\n\r\n      // dedupe by id (teamChats + direct could overlap in edge cases)\r\n      const byId = new Map<string, any>();\r\n      for (const c of merged) byId.set(c.id, c);\r\n\r\n      return NextResponse.json(\r\n        { ok: true, chats: Array.from(byId.values()) },\r\n        { status: 200 }\r\n      );\r\n    } else {\r\n      // Non-admin: list chats where the user is a ChatMember\r\n      const membership =\r\n        await prisma.chatMember.findMany({\r\n          where: { userId },\r\n          select: { chatId: true },\r\n        });\r\n\r\n      if (membership.length === 0) {\r\n        return NextResponse.json(\r\n          { ok: true, chats: [] },\r\n          { status: 200 }\r\n        );\r\n      }\r\n\r\n      const chatIds = membership.map((m) => m.chatId);\r\n\r\n      const chats = await prisma.chat.findMany({\r\n        where: { id: { in: chatIds } },\r\n        include: {\r\n          members: {\r\n            include: {\r\n              user: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  email: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n          team: { select: { id: true, name: true } },\r\n          createdBy: {\r\n            select: { id: true, name: true },\r\n          },\r\n        },\r\n        orderBy: { lastMessageAt: \"desc\" },\r\n      });\r\n\r\n      return NextResponse.json(\r\n        {\r\n          ok: true,\r\n          chats: chats.map((c) =>\r\n            normalizeChat(c, userId)\r\n          ),\r\n        },\r\n        { status: 200 }\r\n      );\r\n    }\r\n  } catch (err) {\r\n    console.error(\"GET /api/chats error:\", err);\r\n    return NextResponse.json(\r\n      { ok: false, error: \"Internal Server Error\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n/* -------------------------------------------------------\r\n   POST /api/chats\r\n   Creates a chat (team group chat or direct chat)\r\n   Body:\r\n     {\r\n       name?: string,\r\n       teamId?: string,\r\n       memberIds?: string[]   // other users (not including the requester) for a direct chat\r\n     }\r\n------------------------------------------------------- */\r\n\r\nfunction mapUserRoleToChatRole(\r\n  userRole: string | null | undefined\r\n) {\r\n  if (userRole === \"MANAGER\") return \"MANAGER\";\r\n  return \"MEMBER\";\r\n}\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const session = await resolveSessionUser(req);\r\n    if (!session) {\r\n      return NextResponse.json(\r\n        {\r\n          ok: false,\r\n          error: \"Unauthorized\",\r\n          chat: null,\r\n        },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    const userId = String(session.id);\r\n    const userRole = session.role ?? null;\r\n    const orgId = session.organizationId ?? null;\r\n\r\n    const body = await safeJson(req);\r\n    const name =\r\n      typeof body.name === \"string\"\r\n        ? body.name.trim()\r\n        : undefined;\r\n    const teamId =\r\n      typeof body.teamId === \"string\"\r\n        ? body.teamId.trim()\r\n        : undefined;\r\n\r\n    let memberIds: string[] = Array.isArray(body.memberIds)\r\n      ? body.memberIds.filter(\r\n          (x: any) => typeof x === \"string\"\r\n        )\r\n      : [];\r\n\r\n    /* ----------------------------------------------\r\n       TEAM CHAT\r\n    ---------------------------------------------- */\r\n    if (teamId) {\r\n      // check team exists\r\n      const team = await prisma.team.findUnique({\r\n        where: { id: teamId },\r\n        select: { id: true, organizationId: true },\r\n      });\r\n      if (!team) {\r\n        return NextResponse.json(\r\n          { ok: false, error: \"Team not found\" },\r\n          { status: 404 }\r\n        );\r\n      }\r\n\r\n      // authorize\r\n      const allowed = await authorizeTeamAccess(\r\n        userId,\r\n        userRole,\r\n        teamId\r\n      );\r\n      if (!allowed) {\r\n        return NextResponse.json(\r\n          { ok: false, error: \"Forbidden\" },\r\n          { status: 403 }\r\n        );\r\n      }\r\n\r\n      // If chat exists, return it\r\n      const existingTeamChat =\r\n        await prisma.chat.findFirst({\r\n          where: { teamId },\r\n          include: {\r\n            members: {\r\n              include: {\r\n                user: {\r\n                  select: {\r\n                    id: true,\r\n                    name: true,\r\n                    email: true,\r\n                  },\r\n                },\r\n              },\r\n            },\r\n            team: {\r\n              select: { id: true, name: true },\r\n            },\r\n            createdBy: {\r\n              select: { id: true, name: true },\r\n            },\r\n          },\r\n        });\r\n\r\n      if (existingTeamChat) {\r\n        return NextResponse.json(\r\n          {\r\n            ok: true,\r\n            created: false,\r\n            chat: normalizeChat(\r\n              existingTeamChat,\r\n              userId\r\n            ),\r\n          },\r\n          { status: 200 }\r\n        );\r\n      }\r\n\r\n      // Get all team members (user ids) and include requester\r\n      const teamMembers =\r\n        await prisma.teamMember.findMany({\r\n          where: { teamId },\r\n          select: { userId: true },\r\n        });\r\n      const toAdd = Array.from(\r\n        new Set(\r\n          [\r\n            ...teamMembers.map((m) => m.userId || \"\"),\r\n            userId,\r\n          ].filter(Boolean)\r\n        )\r\n      );\r\n\r\n      // Remove org admins from membership list ‚Äî admins have implicit access\r\n      // and should not be ChatMembers on team chats\r\n      const users = await prisma.user.findMany({\r\n        where: { id: { in: toAdd } },\r\n        select: { id: true, role: true },\r\n      });\r\n      const filtered = users.filter(\r\n        (u) =>\r\n          String(u.role).toUpperCase() !== \"ADMIN\"\r\n      );\r\n\r\n      // create chat and chat members\r\n      const chat = await prisma.chat.create({\r\n        data: {\r\n          name: name ?? null,\r\n          type: \"TEAM\",\r\n          organization: orgId\r\n            ? { connect: { id: orgId } }\r\n            : undefined,\r\n          team: { connect: { id: teamId } },\r\n          createdBy: { connect: { id: userId } },\r\n          members: {\r\n            create: filtered.map((u) => ({\r\n              user: { connect: { id: u.id } },\r\n              role: mapUserRoleToChatRole(u.role),\r\n            })),\r\n          },\r\n        },\r\n        include: {\r\n          members: {\r\n            include: {\r\n              user: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  email: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n          team: {\r\n            select: { id: true, name: true },\r\n          },\r\n          createdBy: {\r\n            select: { id: true, name: true },\r\n          },\r\n        },\r\n      });\r\n\r\n      // emit chat:created to members & org room (best-effort)\r\n      (async () => {\r\n        try {\r\n          const io =\r\n            (global as any).io ||\r\n            (global as any)._io ||\r\n            (global as any).socketServer;\r\n          const payload = {\r\n            chat: {\r\n              id: chat.id,\r\n              name: chat.name,\r\n              teamId: teamId,\r\n            },\r\n            teamId,\r\n            organizationId: orgId,\r\n          };\r\n          if (io && typeof io.to === \"function\") {\r\n            for (const m of filtered) {\r\n              io.to(`user:${m.id}`).emit(\r\n                \"chat:created\",\r\n                payload\r\n              );\r\n            }\r\n            io.to(`org:${orgId}`).emit(\r\n              \"chat:created\",\r\n              payload\r\n            );\r\n          } else if (\r\n            io &&\r\n            typeof io.emit === \"function\"\r\n          ) {\r\n            io.emit(\"chat:created\", payload);\r\n          }\r\n        } catch (e) {\r\n          console.warn(\r\n            \"[api/chats] emit chat:created failed:\",\r\n            e\r\n          );\r\n        }\r\n      })();\r\n\r\n      return NextResponse.json(\r\n        {\r\n          ok: true,\r\n          created: true,\r\n          chat: normalizeChat(chat, userId),\r\n        },\r\n        { status: 201 }\r\n      );\r\n    }\r\n\r\n    /* ----------------------------------------------\r\n       DIRECT / PRIVATE CHAT\r\n       Enforce ACL rules:\r\n         - ADMIN: can DM MANAGER or ADMIN; cannot DM EMPLOYEE privately\r\n         - MANAGER: can DM ADMIN, other MANAGERs; can DM EMPLOYEE only if employee is in manager's team\r\n         - EMPLOYEE: can DM only team members and their manager\r\n    ---------------------------------------------- */\r\n\r\n    // dedupe and include requester\r\n    const uniqueMemberIds = Array.from(\r\n      new Set([...memberIds, userId])\r\n    );\r\n\r\n    // must have at least one other user to chat with\r\n    if (uniqueMemberIds.length < 2) {\r\n      return NextResponse.json(\r\n        {\r\n          ok: false,\r\n          error: \"At least one other member required\",\r\n        },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Load users for ACL checks\r\n    const otherIds = uniqueMemberIds.filter(\r\n      (id) => id !== userId\r\n    );\r\n    const otherUsers = await prisma.user.findMany({\r\n      where: { id: { in: otherIds } },\r\n      select: {\r\n        id: true,\r\n        role: true,\r\n        organizationId: true,\r\n      },\r\n    });\r\n\r\n    // ensure all targets exist and belong to same org\r\n    const foundIds = new Set(otherUsers.map((u) => u.id));\r\n    for (const tid of otherIds) {\r\n      if (!foundIds.has(tid)) {\r\n        return NextResponse.json(\r\n          {\r\n            ok: false,\r\n            error: `User not found: ${tid}`,\r\n          },\r\n          { status: 404 }\r\n        );\r\n      }\r\n    }\r\n    // ensure same organization\r\n    for (const u of otherUsers) {\r\n      if (orgId && u.organizationId !== orgId) {\r\n        return NextResponse.json(\r\n          {\r\n            ok: false,\r\n            error:\r\n              \"All chat participants must belong to your organization\",\r\n          },\r\n          { status: 400 }\r\n        );\r\n      }\r\n    }\r\n\r\n    // ACL enforcement per target\r\n    for (const target of otherUsers) {\r\n      const tgtRole = String(target.role).toUpperCase();\r\n\r\n      if (userRole === \"ADMIN\") {\r\n        // admin can talk to MANAGER/ADMIN; cannot privately message EMPLOYEE\r\n        if (tgtRole === \"EMPLOYEE\") {\r\n          return NextResponse.json(\r\n            {\r\n              ok: false,\r\n              error:\r\n                \"Admin cannot privately message an employee\",\r\n            },\r\n            { status: 403 }\r\n          );\r\n        }\r\n      } else if (userRole === \"MANAGER\") {\r\n        if (tgtRole === \"EMPLOYEE\") {\r\n          // allow only if that employee is part of one of the manager's teams\r\n          const isInManagerTeam =\r\n            await prisma.teamMember.findFirst({\r\n              where: {\r\n                userId: target.id,\r\n                team: { managerId: userId },\r\n              },\r\n              select: { id: true },\r\n            });\r\n          if (!isInManagerTeam) {\r\n            return NextResponse.json(\r\n              {\r\n                ok: false,\r\n                error:\r\n                  \"Managers can message an employee only if the employee belongs to their team\",\r\n              },\r\n              { status: 403 }\r\n            );\r\n          }\r\n        }\r\n        // manager->manager and manager->admin allowed\r\n      } else {\r\n        // EMPLOYEE\r\n        if (tgtRole === \"ADMIN\") {\r\n          // employees cannot message admin directly\r\n          return NextResponse.json(\r\n            {\r\n              ok: false,\r\n              error:\r\n                \"Employees cannot message admin directly\",\r\n            },\r\n            { status: 403 }\r\n          );\r\n        }\r\n        // If target is manager: ensure manager is manager of employee's team\r\n        if (tgtRole === \"MANAGER\") {\r\n          const managerIsOfEmployee =\r\n            await prisma.teamMember.findFirst({\r\n              where: {\r\n                userId,\r\n                team: { managerId: target.id },\r\n              }, // is employee a member of a team managed by target?\r\n              select: { id: true },\r\n            });\r\n          if (!managerIsOfEmployee) {\r\n            return NextResponse.json(\r\n              {\r\n                ok: false,\r\n                error:\r\n                  \"Employee can message only their manager\",\r\n              },\r\n              { status: 403 }\r\n            );\r\n          }\r\n        }\r\n        // If target is employee: ensure both are in same team\r\n        if (tgtRole === \"EMPLOYEE\") {\r\n          const commonTeam =\r\n            await prisma.teamMember.findFirst({\r\n              where: {\r\n                userId: target.id,\r\n                team: {\r\n                  members: {\r\n                    some: { userId },\r\n                  },\r\n                },\r\n              },\r\n              select: { id: true },\r\n            });\r\n          if (!commonTeam) {\r\n            return NextResponse.json(\r\n              {\r\n                ok: false,\r\n                error:\r\n                  \"Employees can message only members of their team\",\r\n              },\r\n              { status: 403 }\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /* ----------------------------------------------\r\n       DEDUPE DIRECT CHATS:\r\n       if a DIRECT chat already exists with exactly\r\n       these participants, reuse it instead of creating\r\n       a duplicate.\r\n    ---------------------------------------------- */\r\n\r\n    const existingDirectCandidates =\r\n      await prisma.chat.findMany({\r\n        where: {\r\n          type: \"DIRECT\",\r\n          members: {\r\n            some: {\r\n              userId: { in: uniqueMemberIds },\r\n            },\r\n          },\r\n        },\r\n        include: {\r\n          members: {\r\n            include: {\r\n              user: {\r\n                select: {\r\n                  id: true,\r\n                  name: true,\r\n                  email: true,\r\n                },\r\n              },\r\n            },\r\n          },\r\n          team: {\r\n            select: { id: true, name: true },\r\n          },\r\n          createdBy: {\r\n            select: { id: true, name: true },\r\n          },\r\n        },\r\n      });\r\n\r\n    const existingDirect = existingDirectCandidates.find(\r\n      (c: any) => {\r\n        const memberIdsInChat = (c.members ?? [])\r\n          .map(\r\n            (m: any) =>\r\n              m.userId ??\r\n              m.user?.id ??\r\n              null\r\n          )\r\n          .filter(Boolean) as string[];\r\n\r\n        if (\r\n          memberIdsInChat.length !==\r\n          uniqueMemberIds.length\r\n        )\r\n          return false;\r\n\r\n        return uniqueMemberIds.every((id) =>\r\n          memberIdsInChat.includes(id)\r\n        );\r\n      }\r\n    );\r\n\r\n    if (existingDirect) {\r\n      return NextResponse.json(\r\n        {\r\n          ok: true,\r\n          created: false,\r\n          chat: normalizeChat(existingDirect, userId),\r\n        },\r\n        { status: 200 }\r\n      );\r\n    }\r\n\r\n    // Passed ACL checks and no existing chat ‚Äî create new chat\r\n    // For simplicity we create a chat with all participants as ChatMembers; map roles appropriately.\r\n    const participants = await prisma.user.findMany({\r\n      where: { id: { in: uniqueMemberIds } },\r\n      select: { id: true, role: true },\r\n    });\r\n\r\n    const chat = await prisma.chat.create({\r\n      data: {\r\n        name: name ?? null,\r\n        type: \"DIRECT\",\r\n        organization: orgId\r\n          ? { connect: { id: orgId } }\r\n          : undefined,\r\n        createdBy: { connect: { id: userId } },\r\n        members: {\r\n          create: participants.map((p) => ({\r\n            user: { connect: { id: p.id } },\r\n            role: mapUserRoleToChatRole(p.role),\r\n          })),\r\n        },\r\n      },\r\n      include: {\r\n        members: {\r\n          include: {\r\n            user: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                email: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        createdBy: {\r\n          select: { id: true, name: true },\r\n        },\r\n      },\r\n    });\r\n\r\n    // emit chat:created to participants & org room (best-effort)\r\n    (async () => {\r\n      try {\r\n        const io =\r\n          (global as any).io ||\r\n          (global as any)._io ||\r\n          (global as any).socketServer;\r\n        const payload = {\r\n          chat: { id: chat.id, name: chat.name },\r\n          organizationId: orgId,\r\n        };\r\n        if (io && typeof io.to === \"function\") {\r\n          for (const p of participants) {\r\n            io.to(`user:${p.id}`).emit(\r\n              \"chat:created\",\r\n              payload\r\n            );\r\n          }\r\n          if (orgId)\r\n            io.to(`org:${orgId}`).emit(\r\n              \"chat:created\",\r\n              payload\r\n            );\r\n        } else if (\r\n          io &&\r\n          typeof io.emit === \"function\"\r\n        ) {\r\n          io.emit(\"chat:created\", payload);\r\n        }\r\n      } catch (e) {\r\n        console.warn(\r\n          \"[api/chats] emit chat:created failed:\",\r\n          e\r\n        );\r\n      }\r\n    })();\r\n\r\n    return NextResponse.json(\r\n      {\r\n        ok: true,\r\n        created: true,\r\n        chat: normalizeChat(chat, userId),\r\n      },\r\n      { status: 201 }\r\n    );\r\n  } catch (err) {\r\n    console.error(\"POST /api/chats error:\", err);\r\n    return NextResponse.json(\r\n      {\r\n        ok: false,\r\n        error: \"Internal Server Error\",\r\n        chat: null,\r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}
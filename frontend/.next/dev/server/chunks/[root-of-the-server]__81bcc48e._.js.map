{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/socket.ts"],"sourcesContent":["// src/lib/socket.ts\r\n// Small helper to call the socket server's /emit endpoint from backend code.\r\n// Usage:\r\n//   import { emitToRooms } from \"@/lib/socket\";\r\n//   await emitToRooms({ event: \"chat:created\", rooms: [\"user:123\",\"org:abc\"], payload: {...} });\r\n\r\nimport fetch from \"node-fetch\";\r\n\r\nconst SOCKET_SERVER_URL = process.env.SOCKET_SERVER_URL || process.env.NEXT_PUBLIC_SOCKET_URL || \"http://localhost:4001\";\r\nconst SOCKET_SERVER_KEY = process.env.SOCKET_SERVER_KEY || \"\";\r\n\r\ntype EmitArgs = {\r\n  event: string;\r\n  payload?: any;\r\n  rooms?: string[] | string;\r\n  excludeSocketId?: string;\r\n  timeoutMs?: number;\r\n};\r\n\r\nexport async function emitToRooms({ event, payload = {}, rooms, excludeSocketId, timeoutMs = 2000 }: EmitArgs) {\r\n  if (!SOCKET_SERVER_URL) return { ok: false, error: \"no socket server url\" };\r\n  if (!SOCKET_SERVER_KEY) {\r\n    // still allow if no key supplied (not recommended for prod)\r\n    console.warn(\"socket: no SOCKET_SERVER_KEY configured ‚Äî /emit endpoint not protected\");\r\n  }\r\n\r\n  const url = new URL(\"/emit\", SOCKET_SERVER_URL).toString();\r\n  const body = {\r\n    key: SOCKET_SERVER_KEY,\r\n    rooms,\r\n    event,\r\n    payload,\r\n    excludeSocketId,\r\n  };\r\n\r\n  try {\r\n    const controller = new AbortController();\r\n    const id = setTimeout(() => controller.abort(), timeoutMs);\r\n    const resp = await fetch(url, {\r\n      method: \"POST\",\r\n      headers: { \"Content-Type\": \"application/json\" },\r\n      body: JSON.stringify(body),\r\n      signal: controller.signal,\r\n    });\r\n    clearTimeout(id);\r\n    if (!resp.ok) {\r\n      const text = await resp.text().catch(() => \"\");\r\n      return { ok: false, status: resp.status, body: text };\r\n    }\r\n    const json = await resp.json().catch(() => ({}));\r\n    return { ok: true, result: json };\r\n  } catch (err: any) {\r\n    return { ok: false, error: String(err?.message ?? err) };\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,oBAAoB;AACpB,6EAA6E;AAC7E,SAAS;AACT,gDAAgD;AAChD,iGAAiG;;;;;AAEjG;;AAEA,MAAM,oBAAoB,QAAQ,GAAG,CAAC,iBAAiB,IAAI,QAAQ,GAAG,CAAC,sBAAsB,IAAI;AACjG,MAAM,oBAAoB,QAAQ,GAAG,CAAC,iBAAiB,IAAI;AAUpD,eAAe,YAAY,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC,EAAE,KAAK,EAAE,eAAe,EAAE,YAAY,IAAI,EAAY;IAC3G;;IACA,IAAI,CAAC,mBAAmB;QACtB,4DAA4D;QAC5D,QAAQ,IAAI,CAAC;IACf;IAEA,MAAM,MAAM,IAAI,IAAI,SAAS,mBAAmB,QAAQ;IACxD,MAAM,OAAO;QACX,KAAK;QACL;QACA;QACA;QACA;IACF;IAEA,IAAI;QACF,MAAM,aAAa,IAAI;QACvB,MAAM,KAAK,WAAW,IAAM,WAAW,KAAK,IAAI;QAChD,MAAM,OAAO,MAAM,IAAA,0KAAK,EAAC,KAAK;YAC5B,QAAQ;YACR,SAAS;gBAAE,gBAAgB;YAAmB;YAC9C,MAAM,KAAK,SAAS,CAAC;YACrB,QAAQ,WAAW,MAAM;QAC3B;QACA,aAAa;QACb,IAAI,CAAC,KAAK,EAAE,EAAE;YACZ,MAAM,OAAO,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,IAAM;YAC3C,OAAO;gBAAE,IAAI;gBAAO,QAAQ,KAAK,MAAM;gBAAE,MAAM;YAAK;QACtD;QACA,MAAM,OAAO,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,CAAC,CAAC;QAC9C,OAAO;YAAE,IAAI;YAAM,QAAQ;QAAK;IAClC,EAAE,OAAO,KAAU;QACjB,OAAO;YAAE,IAAI;YAAO,OAAO,OAAO,KAAK,WAAW;QAAK;IACzD;AACF","debugId":null}},
    {"offset": {"line": 200, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/socketAdapter.ts"],"sourcesContent":["// src/lib/socketAdapter.ts\r\n// Adapter to forward legacy `global.io` / `global._io` / `global.socketServer`\r\n// calls to the standalone socket server via the /emit HTTP endpoint.\r\n\r\nimport { emitToRooms } from \"@/lib/socket\";\r\n\r\ntype EmitFn = (event: string, payload?: any) => Promise<void> | void;\r\n\r\nfunction makeRoomEmitter(room: string | string[]) {\r\n  return {\r\n    emit: (event: string, payload?: any) => {\r\n      return emitToRooms({ event, payload, rooms: room });\r\n    },\r\n    // allow io.to(room).except(socketId).emit(...) pattern\r\n    except: (socketId: string) => ({\r\n      emit: (event: string, payload?: any) => {\r\n        return emitToRooms({ event, payload, rooms: room, excludeSocketId: socketId });\r\n      },\r\n    }),\r\n  };\r\n}\r\n\r\n// Single shared adapter instance\r\nconst adapter = {\r\n  /**\r\n   * io.emit(\"event\", payload)\r\n   *  -> broadcast globally\r\n   */\r\n  emit: ((event: string, payload?: any) => {\r\n    return emitToRooms({ event, payload });\r\n  }) as EmitFn,\r\n\r\n  /**\r\n   * io.to(\"room\").emit(\"event\", payload)\r\n   *  -> broadcast to specific room(s)\r\n   */\r\n  to: (room: string | string[]) => makeRoomEmitter(room),\r\n};\r\n\r\n// Attach to global only once\r\ndeclare global {\r\n  // eslint-disable-next-line no-var\r\n  var __socketAdapterInitialized: boolean | undefined;\r\n}\r\n\r\nfunction attachGlobals() {\r\n  if (global.__socketAdapterInitialized) return;\r\n  global.__socketAdapterInitialized = true;\r\n\r\n  // These are the names used in your API code:\r\n  // (global as any).io || (global as any)._io || (global as any).socketServer\r\n  const g: any = global;\r\n\r\n  if (!g.io) g.io = adapter;\r\n  if (!g._io) g._io = adapter;\r\n  if (!g.socketServer) g.socketServer = adapter;\r\n}\r\n\r\n// Run immediately on import (server-only)\r\nattachGlobals();\r\n\r\nexport { adapter as socketAdapter };\r\n"],"names":[],"mappings":"AAAA,2BAA2B;AAC3B,+EAA+E;AAC/E,qEAAqE;;;;;AAErE;;AAIA,SAAS,gBAAgB,IAAuB;IAC9C,OAAO;QACL,MAAM,CAAC,OAAe;YACpB,OAAO,IAAA,qIAAW,EAAC;gBAAE;gBAAO;gBAAS,OAAO;YAAK;QACnD;QACA,uDAAuD;QACvD,QAAQ,CAAC,WAAqB,CAAC;gBAC7B,MAAM,CAAC,OAAe;oBACpB,OAAO,IAAA,qIAAW,EAAC;wBAAE;wBAAO;wBAAS,OAAO;wBAAM,iBAAiB;oBAAS;gBAC9E;YACF,CAAC;IACH;AACF;AAEA,iCAAiC;AACjC,MAAM,UAAU;IACd;;;GAGC,GACD,MAAO,CAAC,OAAe;QACrB,OAAO,IAAA,qIAAW,EAAC;YAAE;YAAO;QAAQ;IACtC;IAEA;;;GAGC,GACD,IAAI,CAAC,OAA4B,gBAAgB;AACnD;AAQA,SAAS;IACP,IAAI,OAAO,0BAA0B,EAAE;IACvC,OAAO,0BAA0B,GAAG;IAEpC,6CAA6C;IAC7C,4EAA4E;IAC5E,MAAM,IAAS;IAEf,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG;IAClB,IAAI,CAAC,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG;IACpB,IAAI,CAAC,EAAE,YAAY,EAAE,EAAE,YAAY,GAAG;AACxC;AAEA,0CAA0C;AAC1C","debugId":null}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["// lib/prisma.ts\r\nimport { PrismaClient } from \"@prisma/client\";\r\n// near the top, before exports\r\nimport \"@/lib/socketAdapter\";\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line\r\n  var __prisma__: PrismaClient | undefined;\r\n}\r\nexport const prisma =\r\n  global.__prisma__ ??\r\n  new PrismaClient({\r\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"warn\", \"error\"] : [\"error\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.__prisma__ = prisma;\r\n"],"names":[],"mappings":"AAAA,gBAAgB;;;;;AAChB;AACA,+BAA+B;AAC/B;;;AAMO,MAAM,SACX,OAAO,UAAU,IACjB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAQ;KAAQ,GAAG;AAC7E;AAEF,wCAA2C,OAAO,UAAU,GAAG","debugId":null}},
    {"offset": {"line": 304, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/jwt.ts"],"sourcesContent":["// src/lib/jwt.ts\r\nimport jwt, { JwtPayload } from \"jsonwebtoken\";\r\n\r\nconst SECRET = process.env.JWT_SECRET;\r\nif (!SECRET) {\r\n  if (process.env.NODE_ENV === \"production\") {\r\n    throw new Error(\"JWT_SECRET environment variable must be set in production!\");\r\n  } else {\r\n    console.warn(\"[JWT] Using fallback secret for development\");\r\n  }\r\n}\r\n\r\n/**\r\n * üîê Create a short-lived temp token (email/phone verification)\r\n */\r\nexport function signTemp(payload: Record<string, any>, expiresIn: string = \"15m\"): string {\r\n  const safePayload = { ...payload };\r\n  delete safePayload.exp;\r\n  return jwt.sign(safePayload, SECRET!, { expiresIn });\r\n}\r\n\r\n/**\r\n * ‚úÖ Verify short-lived temp tokens\r\n * Returns payload object or null if invalid/expired\r\n */\r\nexport function verifyTemp(token: string): Record<string, any> | null {\r\n  try {\r\n    return jwt.verify(token, SECRET!) as Record<string, any>;\r\n  } catch (err) {\r\n    console.warn(\"[JWT] verifyTemp failed:\", (err as Error).message);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * üíæ Create a long-lived session token for logged-in users\r\n */\r\nexport function signSession(payload: Record<string, any>, expiresIn: string = \"7d\"): string {\r\n  const safePayload = { ...payload };\r\n  delete safePayload.exp;\r\n  return jwt.sign(safePayload, SECRET!, { expiresIn });\r\n}\r\n\r\n/**\r\n * üîé Verify a session token\r\n * Returns payload object or null if invalid/expired\r\n */\r\nexport function verifySession(token: string): Record<string, any> | null {\r\n  try {\r\n    return jwt.verify(token, SECRET!) as Record<string, any>;\r\n  } catch (err) {\r\n    console.warn(\"[JWT] verifySession failed:\", (err as Error).message);\r\n    return null;\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,iBAAiB;;;;;;;;;;;AACjB;;AAEA,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU;AACrC,IAAI,CAAC,QAAQ;IACX;;SAEO;QACL,QAAQ,IAAI,CAAC;IACf;AACF;AAKO,SAAS,SAAS,OAA4B,EAAE,YAAoB,KAAK;IAC9E,MAAM,cAAc;QAAE,GAAG,OAAO;IAAC;IACjC,OAAO,YAAY,GAAG;IACtB,OAAO,kJAAG,CAAC,IAAI,CAAC,aAAa,QAAS;QAAE;IAAU;AACpD;AAMO,SAAS,WAAW,KAAa;IACtC,IAAI;QACF,OAAO,kJAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAO,KAAK;QACZ,QAAQ,IAAI,CAAC,4BAA4B,AAAC,IAAc,OAAO;QAC/D,OAAO;IACT;AACF;AAKO,SAAS,YAAY,OAA4B,EAAE,YAAoB,IAAI;IAChF,MAAM,cAAc;QAAE,GAAG,OAAO;IAAC;IACjC,OAAO,YAAY,GAAG;IACtB,OAAO,kJAAG,CAAC,IAAI,CAAC,aAAa,QAAS;QAAE;IAAU;AACpD;AAMO,SAAS,cAAc,KAAa;IACzC,IAAI;QACF,OAAO,kJAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAO,KAAK;QACZ,QAAQ,IAAI,CAAC,+BAA+B,AAAC,IAAc,OAAO;QAClE,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 363, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/auth.ts"],"sourcesContent":["// src/lib/auth.ts\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { verifySession } from \"@/lib/jwt\";\r\n\r\nexport type SessionUser = {\r\n  id: string;\r\n  email?: string | null;\r\n  role: string;\r\n  organizationId?: string | null;\r\n};\r\n\r\nexport async function getSessionUser(req: Request): Promise<SessionUser | null> {\r\n  try {\r\n    // 1Ô∏è‚É£ Prefer Authorization header: \"Bearer <token>\"\r\n    let token: string | null = null;\r\n    const authHeader = req.headers.get(\"authorization\");\r\n    if (authHeader?.startsWith(\"Bearer \")) {\r\n      token = authHeader.slice(\"Bearer \".length).trim();\r\n    }\r\n\r\n    // 2Ô∏è‚É£ Fallback to cookies\r\n    if (!token) {\r\n      const cookieHeader = req.headers.get(\"cookie\") || \"\";\r\n      const cookies: Record<string, string> = Object.fromEntries(\r\n        cookieHeader\r\n          .split(\";\")\r\n          .map(c => c.trim().split(\"=\"))\r\n          .map(([k, v]) => [decodeURIComponent(k), decodeURIComponent(v)])\r\n      );\r\n      token = cookies[\"session\"] || cookies[\"token\"] || null;\r\n    }\r\n\r\n    if (!token) return null;\r\n\r\n    // 3Ô∏è‚É£ Verify token safely\r\n    const payload = verifySession(token);\r\n    if (!payload?.id) return null;\r\n\r\n    // 4Ô∏è‚É£ Fetch user from DB\r\n    const user = await prisma.user.findUnique({ where: { id: payload.id } });\r\n    if (!user) return null;\r\n\r\n    return {\r\n      id: user.id,\r\n      email: user.email ?? null,\r\n      role: user.role,\r\n      organizationId: user.organizationId,\r\n    };\r\n  } catch (err: any) {\r\n    console.warn(\"[getSessionUser] error:\", err?.message || err);\r\n    return null;\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,kBAAkB;;;;;AAClB;AACA;;;AASO,eAAe,eAAe,GAAY;IAC/C,IAAI;QACF,oDAAoD;QACpD,IAAI,QAAuB;QAC3B,MAAM,aAAa,IAAI,OAAO,CAAC,GAAG,CAAC;QACnC,IAAI,YAAY,WAAW,YAAY;YACrC,QAAQ,WAAW,KAAK,CAAC,UAAU,MAAM,EAAE,IAAI;QACjD;QAEA,0BAA0B;QAC1B,IAAI,CAAC,OAAO;YACV,MAAM,eAAe,IAAI,OAAO,CAAC,GAAG,CAAC,aAAa;YAClD,MAAM,UAAkC,OAAO,WAAW,CACxD,aACG,KAAK,CAAC,KACN,GAAG,CAAC,CAAA,IAAK,EAAE,IAAI,GAAG,KAAK,CAAC,MACxB,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,GAAK;oBAAC,mBAAmB;oBAAI,mBAAmB;iBAAG;YAEnE,QAAQ,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,QAAQ,IAAI;QACpD;QAEA,IAAI,CAAC,OAAO,OAAO;QAEnB,0BAA0B;QAC1B,MAAM,UAAU,IAAA,oIAAa,EAAC;QAC9B,IAAI,CAAC,SAAS,IAAI,OAAO;QAEzB,yBAAyB;QACzB,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE,IAAI,QAAQ,EAAE;YAAC;QAAE;QACtE,IAAI,CAAC,MAAM,OAAO;QAElB,OAAO;YACL,IAAI,KAAK,EAAE;YACX,OAAO,KAAK,KAAK,IAAI;YACrB,MAAM,KAAK,IAAI;YACf,gBAAgB,KAAK,cAAc;QACrC;IACF,EAAE,OAAO,KAAU;QACjB,QAAQ,IAAI,CAAC,2BAA2B,KAAK,WAAW;QACxD,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 415, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/app/api/chats/route.ts"],"sourcesContent":["// src/app/api/chats/route.ts\r\n\r\nimport { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { getSessionUser } from \"@/lib/auth\";\r\nimport { cookies } from \"next/headers\";\r\nimport jwt from \"jsonwebtoken\";\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET || \"\";\r\n\r\n/* -------------------------------------------------------\r\n   Helpers\r\n------------------------------------------------------- */\r\n\r\nasync function safeJson(req: Request) {\r\n  try {\r\n    return await req.json();\r\n  } catch {\r\n    return {};\r\n  }\r\n}\r\n\r\n/**\r\n * Resolve logged-in user from:\r\n * 1. next-auth helper\r\n * 2. Authorization header\r\n * 3. Session cookie\r\n */\r\nasync function resolveSessionUser(req: Request) {\r\n  // #1 next-auth\r\n  try {\r\n    const u = await getSessionUser(req);\r\n    if (u?.id) return u;\r\n  } catch {}\r\n\r\n  // #2 bearer\r\n  try {\r\n    const auth = req.headers.get(\"authorization\") ?? req.headers.get(\"Authorization\");\r\n    if (auth?.toLowerCase().startsWith(\"bearer \")) {\r\n      const token = auth.slice(7).trim();\r\n      if (token && JWT_SECRET) {\r\n        const payload = jwt.verify(token, JWT_SECRET) as any;\r\n        if (payload?.id) return payload;\r\n      }\r\n    }\r\n  } catch {}\r\n\r\n  // #3 cookie\r\n  try {\r\n    const store = await cookies();\r\n    const token = store.get(\"session\")?.value;\r\n    if (token && JWT_SECRET) {\r\n      const payload = jwt.verify(token, JWT_SECRET) as any;\r\n      if (payload?.id) return payload;\r\n    }\r\n  } catch {}\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Authorize that user can access a team.\r\n * ADMIN ‚Üí always pass\r\n * Manager or Member of team ‚Üí pass\r\n */\r\nasync function authorizeTeamAccess(userId: string, userRole: string | null, teamId: string) {\r\n  if (userRole === \"ADMIN\") return true;\r\n\r\n  const team = await prisma.team.findUnique({\r\n    where: { id: teamId },\r\n    select: { managerId: true },\r\n  });\r\n\r\n  if (!team) return false;\r\n\r\n  // Is manager?\r\n  if (team.managerId === userId) return true;\r\n\r\n  // Is team member?\r\n  const member = await prisma.teamMember.findFirst({\r\n    where: { teamId, userId },\r\n    select: { id: true },\r\n  });\r\n\r\n  return !!member;\r\n}\r\n\r\n/**\r\n * Normalize a chat for frontend use\r\n * Hides admin ChatMember rows when chat.type is TEAM so admin does not appear in the member list.\r\n */\r\nfunction normalizeChat(chat: any) {\r\n  const isTeam = String(chat.type).toUpperCase() === \"TEAM\";\r\n  return {\r\n    id: chat.id,\r\n    name: chat.name ?? (chat.team ? `Team: ${chat.team.name}` : \"Chat\"),\r\n    type: chat.type,\r\n    teamId: chat.teamId ?? null,\r\n    createdBy: chat.createdBy ? { id: chat.createdBy.id, name: chat.createdBy.name } : null,\r\n    members:\r\n      (chat.members ?? [])\r\n        .filter((m: any) => {\r\n          // For team chats, do not expose ChatMember rows with role ADMIN (these are implicit admin access)\r\n          if (isTeam && String(m.role).toUpperCase() === \"ADMIN\") return false;\r\n          return !!(m.user && m.user.id);\r\n        })\r\n        .map((m: any) => ({\r\n          id: m.user.id,\r\n          name: m.user.name,\r\n          email: m.user.email,\r\n          role: m.role,\r\n        })) ?? [],\r\n    lastMessageAt: chat.lastMessageAt?.toISOString?.() ?? null,\r\n    createdAt: chat.createdAt?.toISOString?.() ?? null,\r\n  };\r\n}\r\n\r\n/* -------------------------------------------------------\r\n   GET /api/chats\r\n   - Without query ‚Üí get all chats user is a member of (or org/team chats for admin)\r\n   - With ?teamId= ‚Üí get team chat (0 or 1)\r\n------------------------------------------------------- */\r\n\r\nexport async function GET(req: Request) {\r\n  try {\r\n    const session = await resolveSessionUser(req);\r\n    if (!session) {\r\n      return NextResponse.json({ ok: false, error: \"Unauthorized\", chats: [] }, { status: 401 });\r\n    }\r\n\r\n    const userId = String(session.id);\r\n    const userRole = session.role ?? null;\r\n    const orgId = session.organizationId ?? null;\r\n\r\n    const url = new URL(req.url);\r\n    const teamId = url.searchParams.get(\"teamId\");\r\n\r\n    /* ----------------------------------------------\r\n       TEAM CHAT MODE\r\n    ---------------------------------------------- */\r\n    if (teamId) {\r\n      const chat = await prisma.chat.findFirst({\r\n        where: { teamId },\r\n        include: {\r\n          members: {\r\n            include: {\r\n              user: { select: { id: true, name: true, email: true } },\r\n            },\r\n          },\r\n          team: { select: { id: true, name: true } },\r\n          createdBy: { select: { id: true, name: true } },\r\n        },\r\n      });\r\n\r\n      // If not found, return null\r\n      if (!chat) {\r\n        return NextResponse.json({ ok: true, chat: null }, { status: 200 });\r\n      }\r\n\r\n      // Authorization: admins can view; others must be team members or manager\r\n      const allowed = (userRole === \"ADMIN\") || (await authorizeTeamAccess(userId, userRole, teamId));\r\n      if (!allowed) {\r\n        return NextResponse.json({ ok: false, error: \"Forbidden\", chat: null }, { status: 403 });\r\n      }\r\n\r\n      return NextResponse.json({ ok: true, chat: normalizeChat(chat) }, { status: 200 });\r\n    }\r\n\r\n    /* ----------------------------------------------\r\n       ALL CHATS FOR THIS USER\r\n    ---------------------------------------------- */\r\n\r\n    if (userRole === \"ADMIN\") {\r\n      // Admin: return all TEAM chats in org + any DIRECT/PRIVATE chats where admin is a member\r\n      if (!orgId) {\r\n        return NextResponse.json({ ok: true, chats: [] }, { status: 200 });\r\n      }\r\n\r\n      // fetch team chats in org\r\n      const teamChats = await prisma.chat.findMany({\r\n        where: { organizationId: orgId, type: \"TEAM\" },\r\n        include: {\r\n          members: { include: { user: { select: { id: true, name: true, email: true } } } },\r\n          team: { select: { id: true, name: true } },\r\n          createdBy: { select: { id: true, name: true } },\r\n        },\r\n        orderBy: { lastMessageAt: \"desc\" },\r\n      });\r\n\r\n      // fetch direct/private chats where admin is a member\r\n      const directMembership = await prisma.chatMember.findMany({ where: { userId }, select: { chatId: true } });\r\n      const directChatIds = directMembership.map((m) => m.chatId);\r\n\r\n      const directChats = directChatIds.length > 0\r\n        ? await prisma.chat.findMany({\r\n            where: { id: { in: directChatIds } },\r\n            include: {\r\n              members: { include: { user: { select: { id: true, name: true, email: true } } } },\r\n              team: { select: { id: true, name: true } },\r\n              createdBy: { select: { id: true, name: true } },\r\n            },\r\n            orderBy: { lastMessageAt: \"desc\" },\r\n          })\r\n        : [];\r\n\r\n      // merge and normalize (teamChats first)\r\n      const merged = [...teamChats, ...directChats].map(normalizeChat);\r\n\r\n      // dedupe by id (teamChats + direct could overlap in edge cases)\r\n      const byId = new Map<string, any>();\r\n      for (const c of merged) byId.set(c.id, c);\r\n\r\n      return NextResponse.json({ ok: true, chats: Array.from(byId.values()) }, { status: 200 });\r\n    } else {\r\n      // Non-admin: list chats where the user is a ChatMember\r\n      const membership = await prisma.chatMember.findMany({ where: { userId }, select: { chatId: true } });\r\n\r\n      if (membership.length === 0) {\r\n        return NextResponse.json({ ok: true, chats: [] }, { status: 200 });\r\n      }\r\n\r\n      const chatIds = membership.map((m) => m.chatId);\r\n\r\n      const chats = await prisma.chat.findMany({\r\n        where: { id: { in: chatIds } },\r\n        include: {\r\n          members: { include: { user: { select: { id: true, name: true, email: true } } } },\r\n          team: { select: { id: true, name: true } },\r\n          createdBy: { select: { id: true, name: true } },\r\n        },\r\n        orderBy: { lastMessageAt: \"desc\" },\r\n      });\r\n\r\n      return NextResponse.json({ ok: true, chats: chats.map(normalizeChat) }, { status: 200 });\r\n    }\r\n  } catch (err) {\r\n    console.error(\"GET /api/chats error:\", err);\r\n    return NextResponse.json({ ok: false, error: \"Internal Server Error\" }, { status: 500 });\r\n  }\r\n}\r\n\r\n/* -------------------------------------------------------\r\n   POST /api/chats\r\n   Creates a chat (team group chat or direct chat)\r\n   Body:\r\n     {\r\n       name?: string,\r\n       teamId?: string,\r\n       memberIds?: string[]   // other users (not including the requester) for a direct chat\r\n     }\r\n------------------------------------------------------- */\r\n\r\nfunction mapUserRoleToChatRole(userRole: string | null | undefined) {\r\n  if (userRole === \"MANAGER\") return \"MANAGER\";\r\n  return \"MEMBER\";\r\n}\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const session = await resolveSessionUser(req);\r\n    if (!session) {\r\n      return NextResponse.json({ ok: false, error: \"Unauthorized\", chat: null }, { status: 401 });\r\n    }\r\n\r\n    const userId = String(session.id);\r\n    const userRole = session.role ?? null;\r\n    const orgId = session.organizationId ?? null;\r\n\r\n    const body = await safeJson(req);\r\n    const name = typeof body.name === \"string\" ? body.name.trim() : undefined;\r\n    const teamId = typeof body.teamId === \"string\" ? body.teamId.trim() : undefined;\r\n\r\n    let memberIds: string[] = Array.isArray(body.memberIds) ? body.memberIds.filter((x: any) => typeof x === \"string\") : [];\r\n\r\n    /* ----------------------------------------------\r\n       TEAM CHAT\r\n    ---------------------------------------------- */\r\n    if (teamId) {\r\n      // check team exists\r\n      const team = await prisma.team.findUnique({ where: { id: teamId }, select: { id: true, organizationId: true } });\r\n      if (!team) {\r\n        return NextResponse.json({ ok: false, error: \"Team not found\" }, { status: 404 });\r\n      }\r\n      // authorize\r\n      const allowed = await authorizeTeamAccess(userId, userRole, teamId);\r\n      if (!allowed) {\r\n        return NextResponse.json({ ok: false, error: \"Forbidden\" }, { status: 403 });\r\n      }\r\n\r\n      // If chat exists, return it\r\n      const existingTeamChat = await prisma.chat.findFirst({\r\n        where: { teamId },\r\n        include: {\r\n          members: { include: { user: { select: { id: true, name: true, email: true } } } },\r\n          team: { select: { id: true, name: true } },\r\n          createdBy: { select: { id: true, name: true } },\r\n        },\r\n      });\r\n\r\n      if (existingTeamChat) {\r\n        return NextResponse.json({ ok: true, created: false, chat: normalizeChat(existingTeamChat) }, { status: 200 });\r\n      }\r\n\r\n      // Get all team members (user ids) and include requester\r\n      const teamMembers = await prisma.teamMember.findMany({ where: { teamId }, select: { userId: true } });\r\n      const toAdd = Array.from(new Set([...(teamMembers.map((m) => m.userId || \"\")), userId].filter(Boolean)));\r\n\r\n      // Remove org admins from membership list ‚Äî admins have implicit access and should not be ChatMembers on team chats\r\n      const users = await prisma.user.findMany({ where: { id: { in: toAdd } }, select: { id: true, role: true } });\r\n      const filtered = users.filter((u) => String(u.role).toUpperCase() !== \"ADMIN\");\r\n\r\n      // create chat and chat members\r\n      const chat = await prisma.chat.create({\r\n        data: {\r\n          name: name ?? null,\r\n          type: \"TEAM\",\r\n          organization: orgId ? { connect: { id: orgId } } : undefined,\r\n          team: { connect: { id: teamId } },\r\n          createdBy: { connect: { id: userId } },\r\n          members: {\r\n            create: filtered.map((u) => ({\r\n              user: { connect: { id: u.id } },\r\n              role: mapUserRoleToChatRole(u.role),\r\n            })),\r\n          },\r\n        },\r\n        include: {\r\n          members: { include: { user: { select: { id: true, name: true, email: true } } } },\r\n          team: { select: { id: true, name: true } },\r\n          createdBy: { select: { id: true, name: true } },\r\n        },\r\n      });\r\n\r\n      // emit chat:created to members & org room (best-effort)\r\n      (async () => {\r\n        try {\r\n          const io = (global as any).io || (global as any)._io || (global as any).socketServer;\r\n          const payload = { chat: { id: chat.id, name: chat.name, teamId: teamId }, teamId, organizationId: orgId };\r\n          if (io && typeof io.to === \"function\") {\r\n            for (const m of filtered) {\r\n              io.to(`user:${m.id}`).emit(\"chat:created\", payload);\r\n            }\r\n            io.to(`org:${orgId}`).emit(\"chat:created\", payload);\r\n          } else if (io && typeof io.emit === \"function\") {\r\n            io.emit(\"chat:created\", payload);\r\n          }\r\n        } catch (e) {\r\n          console.warn(\"[api/chats] emit chat:created failed:\", e);\r\n        }\r\n      })();\r\n\r\n      return NextResponse.json({ ok: true, created: true, chat: normalizeChat(chat) }, { status: 201 });\r\n    }\r\n\r\n    /* ----------------------------------------------\r\n       DIRECT / PRIVATE CHAT\r\n       Enforce ACL rules:\r\n         - ADMIN: can DM MANAGER or ADMIN; cannot DM EMPLOYEE privately\r\n         - MANAGER: can DM ADMIN, other MANAGERs; can DM EMPLOYEE only if employee is in manager's team\r\n         - EMPLOYEE: can DM only team members and their manager\r\n    ---------------------------------------------- */\r\n\r\n    // dedupe and include requester\r\n    const uniqueMemberIds = Array.from(new Set([...memberIds, userId]));\r\n\r\n    // must have at least one other user to chat with\r\n    if (uniqueMemberIds.length < 2) {\r\n      return NextResponse.json({ ok: false, error: \"At least one other member required\" }, { status: 400 });\r\n    }\r\n\r\n    // Load users for ACL checks\r\n    const otherIds = uniqueMemberIds.filter((id) => id !== userId);\r\n    const otherUsers = await prisma.user.findMany({ where: { id: { in: otherIds } }, select: { id: true, role: true, organizationId: true } });\r\n\r\n    // ensure all targets exist and belong to same org\r\n    const foundIds = new Set(otherUsers.map((u) => u.id));\r\n    for (const tid of otherIds) {\r\n      if (!foundIds.has(tid)) {\r\n        return NextResponse.json({ ok: false, error: `User not found: ${tid}` }, { status: 404 });\r\n      }\r\n    }\r\n    // ensure same organization\r\n    for (const u of otherUsers) {\r\n      if (orgId && u.organizationId !== orgId) {\r\n        return NextResponse.json({ ok: false, error: \"All chat participants must belong to your organization\" }, { status: 400 });\r\n      }\r\n    }\r\n\r\n    // ACL enforcement per target\r\n    for (const target of otherUsers) {\r\n      const tgtRole = String(target.role).toUpperCase();\r\n\r\n      if (userRole === \"ADMIN\") {\r\n        // admin can talk to MANAGER/ADMIN; cannot privately message EMPLOYEE\r\n        if (tgtRole === \"EMPLOYEE\") {\r\n          return NextResponse.json({ ok: false, error: \"Admin cannot privately message an employee\" }, { status: 403 });\r\n        }\r\n      } else if (userRole === \"MANAGER\") {\r\n        if (tgtRole === \"EMPLOYEE\") {\r\n          // allow only if that employee is part of one of the manager's teams\r\n          const isInManagerTeam = await prisma.teamMember.findFirst({\r\n            where: {\r\n              userId: target.id,\r\n              team: { managerId: userId },\r\n            },\r\n            select: { id: true },\r\n          });\r\n          if (!isInManagerTeam) {\r\n            return NextResponse.json({ ok: false, error: \"Managers can message an employee only if the employee belongs to their team\" }, { status: 403 });\r\n          }\r\n        }\r\n        // manager->manager and manager->admin allowed\r\n      } else {\r\n        // EMPLOYEE\r\n        if (tgtRole === \"ADMIN\") {\r\n          // employees can message admin? original design: employees cannot message other team managers? Your spec: \"employees will be able to communicate within each other of that particular group or team in which they are assigned and with their respective manager.\" ‚Äî they can message their manager but not admin.\r\n          return NextResponse.json({ ok: false, error: \"Employees cannot message admin directly\" }, { status: 403 });\r\n        }\r\n        // If target is manager: ensure manager is manager of employee's team\r\n        if (tgtRole === \"MANAGER\") {\r\n          const managerIsOfEmployee = await prisma.teamMember.findFirst({\r\n            where: { userId, team: { managerId: target.id } }, // is employee a member of a team managed by target?\r\n            select: { id: true },\r\n          });\r\n          if (!managerIsOfEmployee) {\r\n            return NextResponse.json({ ok: false, error: \"Employee can message only their manager\" }, { status: 403 });\r\n          }\r\n        }\r\n        // If target is employee: ensure both are in same team\r\n        if (tgtRole === \"EMPLOYEE\") {\r\n          const commonTeam = await prisma.teamMember.findFirst({\r\n            where: {\r\n              userId: target.id,\r\n              team: { members: { some: { userId } } },\r\n            },\r\n            select: { id: true },\r\n          });\r\n          // simpler query: check if there exists a TeamMember row for employee target with team that also has a member userId\r\n          // fallback: check team intersection\r\n          if (!commonTeam) {\r\n            return NextResponse.json({ ok: false, error: \"Employees can message only members of their team\" }, { status: 403 });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Passed ACL checks ‚Äî create chat\r\n    // For simplicity we create a chat with all participants as ChatMembers; map roles appropriately; do not mark admins as ChatMember for team chats (there is no team here).\r\n    const participants = await prisma.user.findMany({\r\n      where: { id: { in: uniqueMemberIds } },\r\n      select: { id: true, role: true },\r\n    });\r\n\r\n    const chat = await prisma.chat.create({\r\n      data: {\r\n        name: name ?? null,\r\n        type: \"DIRECT\",\r\n        organization: orgId ? { connect: { id: orgId } } : undefined,\r\n        createdBy: { connect: { id: userId } },\r\n        members: {\r\n          create: participants.map((p) => ({\r\n            user: { connect: { id: p.id } },\r\n            role: mapUserRoleToChatRole(p.role),\r\n          })),\r\n        },\r\n      },\r\n      include: {\r\n        members: { include: { user: { select: { id: true, name: true, email: true } } } },\r\n        createdBy: { select: { id: true, name: true } },\r\n      },\r\n    });\r\n\r\n    // emit chat:created to participants & org room (best-effort)\r\n    (async () => {\r\n      try {\r\n        const io = (global as any).io || (global as any)._io || (global as any).socketServer;\r\n        const payload = { chat: { id: chat.id, name: chat.name }, organizationId: orgId };\r\n        if (io && typeof io.to === \"function\") {\r\n          for (const p of participants) {\r\n            io.to(`user:${p.id}`).emit(\"chat:created\", payload);\r\n          }\r\n          if (orgId) io.to(`org:${orgId}`).emit(\"chat:created\", payload);\r\n        } else if (io && typeof io.emit === \"function\") {\r\n          io.emit(\"chat:created\", payload);\r\n        }\r\n      } catch (e) {\r\n        console.warn(\"[api/chats] emit chat:created failed:\", e);\r\n      }\r\n    })();\r\n\r\n    return NextResponse.json({ ok: true, created: true, chat: normalizeChat(chat) }, { status: 201 });\r\n  } catch (err) {\r\n    console.error(\"POST /api/chats error:\", err);\r\n    return NextResponse.json({ ok: false, error: \"Internal Server Error\", chat: null }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}
{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["// lib/prisma.ts\r\nimport { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line\r\n  var __prisma__: PrismaClient | undefined;\r\n}\r\nexport const prisma =\r\n  global.__prisma__ ??\r\n  new PrismaClient({\r\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"warn\", \"error\"] : [\"error\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.__prisma__ = prisma;\r\n"],"names":[],"mappings":"AAAA,gBAAgB;;;;;AAChB;;AAMO,MAAM,SACX,OAAO,UAAU,IACjB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAQ;KAAQ,GAAG;AAC7E;AAEF,wCAA2C,OAAO,UAAU,GAAG","debugId":null}},
    {"offset": {"line": 101, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/jwt.ts"],"sourcesContent":["// src/lib/jwt.ts\r\nimport jwt, { JwtPayload } from \"jsonwebtoken\";\r\n\r\nconst SECRET = process.env.JWT_SECRET;\r\nif (!SECRET) {\r\n  if (process.env.NODE_ENV === \"production\") {\r\n    throw new Error(\"JWT_SECRET environment variable must be set in production!\");\r\n  } else {\r\n    console.warn(\"[JWT] Using fallback secret for development\");\r\n  }\r\n}\r\n\r\n/**\r\n * üîê Create a short-lived temp token (email/phone verification)\r\n */\r\nexport function signTemp(payload: Record<string, any>, expiresIn: string = \"15m\"): string {\r\n  const safePayload = { ...payload };\r\n  delete safePayload.exp;\r\n  return jwt.sign(safePayload, SECRET!, { expiresIn });\r\n}\r\n\r\n/**\r\n * ‚úÖ Verify short-lived temp tokens\r\n * Returns payload object or null if invalid/expired\r\n */\r\nexport function verifyTemp(token: string): Record<string, any> | null {\r\n  try {\r\n    return jwt.verify(token, SECRET!) as Record<string, any>;\r\n  } catch (err) {\r\n    console.warn(\"[JWT] verifyTemp failed:\", (err as Error).message);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * üíæ Create a long-lived session token for logged-in users\r\n */\r\nexport function signSession(payload: Record<string, any>, expiresIn: string = \"7d\"): string {\r\n  const safePayload = { ...payload };\r\n  delete safePayload.exp;\r\n  return jwt.sign(safePayload, SECRET!, { expiresIn });\r\n}\r\n\r\n/**\r\n * üîé Verify a session token\r\n * Returns payload object or null if invalid/expired\r\n */\r\nexport function verifySession(token: string): Record<string, any> | null {\r\n  try {\r\n    return jwt.verify(token, SECRET!) as Record<string, any>;\r\n  } catch (err) {\r\n    console.warn(\"[JWT] verifySession failed:\", (err as Error).message);\r\n    return null;\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,iBAAiB;;;;;;;;;;;AACjB;;AAEA,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU;AACrC,IAAI,CAAC,QAAQ;IACX;;SAEO;QACL,QAAQ,IAAI,CAAC;IACf;AACF;AAKO,SAAS,SAAS,OAA4B,EAAE,YAAoB,KAAK;IAC9E,MAAM,cAAc;QAAE,GAAG,OAAO;IAAC;IACjC,OAAO,YAAY,GAAG;IACtB,OAAO,kJAAG,CAAC,IAAI,CAAC,aAAa,QAAS;QAAE;IAAU;AACpD;AAMO,SAAS,WAAW,KAAa;IACtC,IAAI;QACF,OAAO,kJAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAO,KAAK;QACZ,QAAQ,IAAI,CAAC,4BAA4B,AAAC,IAAc,OAAO;QAC/D,OAAO;IACT;AACF;AAKO,SAAS,YAAY,OAA4B,EAAE,YAAoB,IAAI;IAChF,MAAM,cAAc;QAAE,GAAG,OAAO;IAAC;IACjC,OAAO,YAAY,GAAG;IACtB,OAAO,kJAAG,CAAC,IAAI,CAAC,aAAa,QAAS;QAAE;IAAU;AACpD;AAMO,SAAS,cAAc,KAAa;IACzC,IAAI;QACF,OAAO,kJAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAO,KAAK;QACZ,QAAQ,IAAI,CAAC,+BAA+B,AAAC,IAAc,OAAO;QAClE,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 160, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/app/api/auth/login/route.ts"],"sourcesContent":["// app/api/auth/login/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport bcrypt from \"bcrypt\";\r\nimport { signSession } from \"@/lib/jwt\";\r\n\r\n/**\r\n * POST /api/auth/login\r\n *\r\n * Expectations:\r\n * - Body: { email?: string, phone?: string, password: string }\r\n * - Creates an HttpOnly cookie named `session` with a JWT on success.\r\n * - Returns minimal user info on success: { ok: true, user: { id, email, phone, role } }\r\n *\r\n * Notes:\r\n * - Ensure your client sends `credentials: \"same-origin\"` when calling this route,\r\n *   otherwise the browser will ignore the Set-Cookie header.\r\n * - Adapt the optional account lockout / audit logging bits to your schema if you want them.\r\n */\r\n\r\ntype LoginBody = { email?: string; phone?: string; password?: string };\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const body: LoginBody = (await req.json()) ?? {};\r\n    let { email, phone, password } = body;\r\n\r\n    // Basic validation\r\n    if ((!email && !phone) || !password) {\r\n      return NextResponse.json({ error: \"missing_credentials\" }, { status: 400 });\r\n    }\r\n\r\n    // Normalize inputs\r\n    if (email) email = String(email).trim().toLowerCase();\r\n    if (phone) phone = String(phone).trim();\r\n    password = String(password);\r\n\r\n    // ----- Find user -----\r\n    let user: any | null = null;\r\n    if (email) {\r\n      user = await prisma.user.findUnique({\r\n        where: { email },\r\n        select: {\r\n          id: true,\r\n          email: true,\r\n          phone: true,\r\n          passwordHash: true,\r\n          role: true,\r\n          organizationId: true,\r\n          phoneVerified: true,\r\n          emailVerified: true,\r\n          isActive: true,\r\n          // OPTIONAL: fields for lockout/audit (uncomment if present in schema)\r\n          // failedLoginAttempts: true,\r\n          // lockedUntil: true,\r\n        },\r\n      });\r\n    } else {\r\n      user = await prisma.user.findFirst({\r\n        where: { phone },\r\n        select: {\r\n          id: true,\r\n          email: true,\r\n          phone: true,\r\n          passwordHash: true,\r\n          role: true,\r\n          organizationId: true,\r\n          phoneVerified: true,\r\n          emailVerified: true,\r\n          isActive: true,\r\n          // failedLoginAttempts: true,\r\n          // lockedUntil: true,\r\n        },\r\n      });\r\n    }\r\n\r\n    // If user not found or no passwordHash -> generic invalid_credentials\r\n    if (!user || !user.passwordHash) {\r\n      // OPTIONAL: record failed login attempt in DB for audit/lockout\r\n      // await prisma.authLog.create({ data: { type: 'login_failed', identifier: email || phone, reason: 'not_found' } });\r\n\r\n      return NextResponse.json({ error: \"invalid_credentials\" }, { status: 401 });\r\n    }\r\n\r\n    // OPTIONAL: account lockout check (requires fields in your schema)\r\n    // if (user.lockedUntil && new Date(user.lockedUntil) > new Date()) {\r\n    //   return NextResponse.json({ error: \"account_locked\", message: \"Too many failed attempts. Try later.\" }, { status: 423 });\r\n    // }\r\n\r\n    // ----- Verify password -----\r\n    const isPasswordValid = await bcrypt.compare(password, user.passwordHash);\r\n    if (!isPasswordValid) {\r\n      // OPTIONAL: increment failedLoginAttempts and set lockout if threshold reached\r\n      // await prisma.user.update({ where: { id: user.id }, data: { failedLoginAttempts: { increment: 1 } } });\r\n\r\n      // OPTIONAL audit log\r\n      // await prisma.authLog.create({ data: { userId: user.id, type: 'login_failed', metadata: { reason: 'bad_password' } } });\r\n\r\n      return NextResponse.json({ error: \"invalid_credentials\" }, { status: 401 });\r\n    }\r\n\r\n    // ----- Account activation check -----\r\n    const hasIsActive = Object.prototype.hasOwnProperty.call(user, \"isActive\");\r\n    const isActive = hasIsActive ? Boolean(user.isActive) : (Boolean(user.phoneVerified) && Boolean(user.emailVerified));\r\n\r\n    if (!isActive) {\r\n      const showDetails = process.env.NODE_ENV !== \"production\";\r\n      const details = showDetails ? { phoneVerified: Boolean(user.phoneVerified), emailVerified: Boolean(user.emailVerified) } : undefined;\r\n\r\n      // OPTIONAL: log this event\r\n      // await prisma.authLog.create({ data: { userId: user.id, type: 'login_attempt_inactive' } });\r\n\r\n      return NextResponse.json(\r\n        {\r\n          error: \"account_not_active\",\r\n          message: \"account_not_active: verify_email_and_phone\",\r\n          details,\r\n        },\r\n        { status: 403 }\r\n      );\r\n    }\r\n\r\n    // ----- Create session token -----\r\n    // Keep payload small: id, role, organizationId\r\n    const payload = {\r\n      id: user.id,\r\n      role: user.role ?? null,\r\n      organizationId: user.organizationId ?? null,\r\n    };\r\n\r\n    // signSession should return a compact JWT string\r\n    const sessionToken = signSession(payload, \"7d\");\r\n\r\n    // Optional: create a server-side session record tying token -> user id (safer for revoke / logout)\r\n    // const sessionRecord = await prisma.session.create({ data: { userId: user.id, tokenHash: hash(sessionToken), expiresAt: addDays(new Date(), 7) } });\r\n\r\n    // ----- Set cookie using NextResponse API (safer than manual header) -----\r\n    const maxAge = 7 * 24 * 60 * 60; // 7 days in seconds\r\n    const isProd = process.env.NODE_ENV === \"production\";\r\n\r\n    const res = NextResponse.json(\r\n      {\r\n        ok: true,\r\n        user: { id: user.id, email: user.email ?? null, phone: user.phone ?? null, role: user.role ?? null },\r\n      },\r\n      { status: 200 }\r\n    );\r\n\r\n    res.cookies.set({\r\n      name: \"session\",\r\n      value: sessionToken,\r\n      httpOnly: true,\r\n      sameSite: \"lax\", // or 'strict' depending on your needs\r\n      path: \"/\",\r\n      maxAge,\r\n      secure: isProd, // secure only in production (HTTPS)\r\n    });\r\n\r\n    // OPTIONAL: set a secondary non-http-only cookie for client UI (CSRF or avatar small data),\r\n    // but avoid storing sensitive tokens in non-HttpOnly cookies.\r\n    // res.cookies.set({ name: 'session_preview', value: user.email ?? '', maxAge, path: '/', secure: isProd });\r\n\r\n    // OPTIONAL: audit log of successful login\r\n    // await prisma.authLog.create({ data: { userId: user.id, type: 'login_success', metadata: { ip: 'TODO: capture ip if available' } } });\r\n\r\n    return res;\r\n  } catch (err: any) {\r\n    console.error(\"[Login Error]\", err);\r\n    // Do not leak internal errors in production\r\n    return NextResponse.json({ error: process.env.NODE_ENV === \"production\" ? \"internal_server_error\" : err?.message ?? \"internal_server_error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}
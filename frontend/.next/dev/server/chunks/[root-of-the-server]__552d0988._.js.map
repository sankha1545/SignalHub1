{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/socket.ts"],"sourcesContent":["// src/lib/socket.ts\r\n// Small helper to call the socket server's /emit endpoint from backend code.\r\n// Usage:\r\n//   import { emitToRooms } from \"@/lib/socket\";\r\n//   await emitToRooms({ event: \"chat:created\", rooms: [\"user:123\",\"org:abc\"], payload: {...} });\r\n\r\nimport fetch from \"node-fetch\";\r\n\r\nconst SOCKET_SERVER_URL = process.env.SOCKET_SERVER_URL || process.env.NEXT_PUBLIC_SOCKET_URL || \"http://localhost:4001\";\r\nconst SOCKET_SERVER_KEY = process.env.SOCKET_SERVER_KEY || \"\";\r\n\r\ntype EmitArgs = {\r\n  event: string;\r\n  payload?: any;\r\n  rooms?: string[] | string;\r\n  excludeSocketId?: string;\r\n  timeoutMs?: number;\r\n};\r\n\r\nexport async function emitToRooms({ event, payload = {}, rooms, excludeSocketId, timeoutMs = 2000 }: EmitArgs) {\r\n  if (!SOCKET_SERVER_URL) return { ok: false, error: \"no socket server url\" };\r\n  if (!SOCKET_SERVER_KEY) {\r\n    // still allow if no key supplied (not recommended for prod)\r\n    console.warn(\"socket: no SOCKET_SERVER_KEY configured — /emit endpoint not protected\");\r\n  }\r\n\r\n  const url = new URL(\"/emit\", SOCKET_SERVER_URL).toString();\r\n  const body = {\r\n    key: SOCKET_SERVER_KEY,\r\n    rooms,\r\n    event,\r\n    payload,\r\n    excludeSocketId,\r\n  };\r\n\r\n  try {\r\n    const controller = new AbortController();\r\n    const id = setTimeout(() => controller.abort(), timeoutMs);\r\n    const resp = await fetch(url, {\r\n      method: \"POST\",\r\n      headers: { \"Content-Type\": \"application/json\" },\r\n      body: JSON.stringify(body),\r\n      signal: controller.signal,\r\n    });\r\n    clearTimeout(id);\r\n    if (!resp.ok) {\r\n      const text = await resp.text().catch(() => \"\");\r\n      return { ok: false, status: resp.status, body: text };\r\n    }\r\n    const json = await resp.json().catch(() => ({}));\r\n    return { ok: true, result: json };\r\n  } catch (err: any) {\r\n    return { ok: false, error: String(err?.message ?? err) };\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,oBAAoB;AACpB,6EAA6E;AAC7E,SAAS;AACT,gDAAgD;AAChD,iGAAiG;;;;;AAEjG;;AAEA,MAAM,oBAAoB,QAAQ,GAAG,CAAC,iBAAiB,IAAI,QAAQ,GAAG,CAAC,sBAAsB,IAAI;AACjG,MAAM,oBAAoB,QAAQ,GAAG,CAAC,iBAAiB,IAAI;AAUpD,eAAe,YAAY,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC,EAAE,KAAK,EAAE,eAAe,EAAE,YAAY,IAAI,EAAY;IAC3G;;IACA,IAAI,CAAC,mBAAmB;QACtB,4DAA4D;QAC5D,QAAQ,IAAI,CAAC;IACf;IAEA,MAAM,MAAM,IAAI,IAAI,SAAS,mBAAmB,QAAQ;IACxD,MAAM,OAAO;QACX,KAAK;QACL;QACA;QACA;QACA;IACF;IAEA,IAAI;QACF,MAAM,aAAa,IAAI;QACvB,MAAM,KAAK,WAAW,IAAM,WAAW,KAAK,IAAI;QAChD,MAAM,OAAO,MAAM,IAAA,0KAAK,EAAC,KAAK;YAC5B,QAAQ;YACR,SAAS;gBAAE,gBAAgB;YAAmB;YAC9C,MAAM,KAAK,SAAS,CAAC;YACrB,QAAQ,WAAW,MAAM;QAC3B;QACA,aAAa;QACb,IAAI,CAAC,KAAK,EAAE,EAAE;YACZ,MAAM,OAAO,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,IAAM;YAC3C,OAAO;gBAAE,IAAI;gBAAO,QAAQ,KAAK,MAAM;gBAAE,MAAM;YAAK;QACtD;QACA,MAAM,OAAO,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,CAAC,CAAC;QAC9C,OAAO;YAAE,IAAI;YAAM,QAAQ;QAAK;IAClC,EAAE,OAAO,KAAU;QACjB,OAAO;YAAE,IAAI;YAAO,OAAO,OAAO,KAAK,WAAW;QAAK;IACzD;AACF","debugId":null}},
    {"offset": {"line": 200, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/socketAdapter.ts"],"sourcesContent":["// src/lib/socketAdapter.ts\r\n// Adapter to forward legacy `global.io` / `global._io` / `global.socketServer`\r\n// calls to the standalone socket server via the /emit HTTP endpoint.\r\n\r\nimport { emitToRooms } from \"@/lib/socket\";\r\n\r\ntype EmitFn = (event: string, payload?: any) => Promise<void> | void;\r\n\r\nfunction makeRoomEmitter(room: string | string[]) {\r\n  return {\r\n    emit: (event: string, payload?: any) => {\r\n      return emitToRooms({ event, payload, rooms: room });\r\n    },\r\n    // allow io.to(room).except(socketId).emit(...) pattern\r\n    except: (socketId: string) => ({\r\n      emit: (event: string, payload?: any) => {\r\n        return emitToRooms({ event, payload, rooms: room, excludeSocketId: socketId });\r\n      },\r\n    }),\r\n  };\r\n}\r\n\r\n// Single shared adapter instance\r\nconst adapter = {\r\n  /**\r\n   * io.emit(\"event\", payload)\r\n   *  -> broadcast globally\r\n   */\r\n  emit: ((event: string, payload?: any) => {\r\n    return emitToRooms({ event, payload });\r\n  }) as EmitFn,\r\n\r\n  /**\r\n   * io.to(\"room\").emit(\"event\", payload)\r\n   *  -> broadcast to specific room(s)\r\n   */\r\n  to: (room: string | string[]) => makeRoomEmitter(room),\r\n};\r\n\r\n// Attach to global only once\r\ndeclare global {\r\n  // eslint-disable-next-line no-var\r\n  var __socketAdapterInitialized: boolean | undefined;\r\n}\r\n\r\nfunction attachGlobals() {\r\n  if (global.__socketAdapterInitialized) return;\r\n  global.__socketAdapterInitialized = true;\r\n\r\n  // These are the names used in your API code:\r\n  // (global as any).io || (global as any)._io || (global as any).socketServer\r\n  const g: any = global;\r\n\r\n  if (!g.io) g.io = adapter;\r\n  if (!g._io) g._io = adapter;\r\n  if (!g.socketServer) g.socketServer = adapter;\r\n}\r\n\r\n// Run immediately on import (server-only)\r\nattachGlobals();\r\n\r\nexport { adapter as socketAdapter };\r\n"],"names":[],"mappings":"AAAA,2BAA2B;AAC3B,+EAA+E;AAC/E,qEAAqE;;;;;AAErE;;AAIA,SAAS,gBAAgB,IAAuB;IAC9C,OAAO;QACL,MAAM,CAAC,OAAe;YACpB,OAAO,IAAA,qIAAW,EAAC;gBAAE;gBAAO;gBAAS,OAAO;YAAK;QACnD;QACA,uDAAuD;QACvD,QAAQ,CAAC,WAAqB,CAAC;gBAC7B,MAAM,CAAC,OAAe;oBACpB,OAAO,IAAA,qIAAW,EAAC;wBAAE;wBAAO;wBAAS,OAAO;wBAAM,iBAAiB;oBAAS;gBAC9E;YACF,CAAC;IACH;AACF;AAEA,iCAAiC;AACjC,MAAM,UAAU;IACd;;;GAGC,GACD,MAAO,CAAC,OAAe;QACrB,OAAO,IAAA,qIAAW,EAAC;YAAE;YAAO;QAAQ;IACtC;IAEA;;;GAGC,GACD,IAAI,CAAC,OAA4B,gBAAgB;AACnD;AAQA,SAAS;IACP,IAAI,OAAO,0BAA0B,EAAE;IACvC,OAAO,0BAA0B,GAAG;IAEpC,6CAA6C;IAC7C,4EAA4E;IAC5E,MAAM,IAAS;IAEf,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG;IAClB,IAAI,CAAC,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG;IACpB,IAAI,CAAC,EAAE,YAAY,EAAE,EAAE,YAAY,GAAG;AACxC;AAEA,0CAA0C;AAC1C","debugId":null}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["// lib/prisma.ts\r\nimport { PrismaClient } from \"@prisma/client\";\r\n// near the top, before exports\r\nimport \"@/lib/socketAdapter\";\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line\r\n  var __prisma__: PrismaClient | undefined;\r\n}\r\nexport const prisma =\r\n  global.__prisma__ ??\r\n  new PrismaClient({\r\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"warn\", \"error\"] : [\"error\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.__prisma__ = prisma;\r\n"],"names":[],"mappings":"AAAA,gBAAgB;;;;;AAChB;AACA,+BAA+B;AAC/B;;;AAMO,MAAM,SACX,OAAO,UAAU,IACjB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAQ;KAAQ,GAAG;AAC7E;AAEF,wCAA2C,OAAO,UAAU,GAAG","debugId":null}},
    {"offset": {"line": 286, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/app/api/dashboard/teams/route.ts"],"sourcesContent":["// src/app/api/dashboard/teams/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\n\r\n/**\r\n * Simple shim used by some frontend pages expecting /api/dashboard/teams.\r\n * This returns the same data shape as /api/teams GET would.\r\n */\r\nexport async function GET(req: Request) {\r\n  try {\r\n    const url = new URL(req.url);\r\n    const organizationId = url.searchParams.get(\"organizationId\") ?? null;\r\n    if (!organizationId) {\r\n      return NextResponse.json({ ok: false, message: \"organizationId required\" }, { status: 400 });\r\n    }\r\n\r\n    // Keep this lightweight — frontend will resolve members via /api/users if needed\r\n    const teams = await prisma.team.findMany({\r\n      where: { organizationId },\r\n      orderBy: { createdAt: \"desc\" },\r\n      select: {\r\n        id: true,\r\n        name: true,\r\n        description: true,\r\n        leadId: true,\r\n        featured: true,\r\n        gradient: true,\r\n        projects: true,\r\n        completion: true,\r\n        createdAt: true,\r\n      },\r\n    });\r\n\r\n    const normalized = teams.map((t) => ({\r\n      id: t.id,\r\n      name: t.name,\r\n      description: t.description ?? \"\",\r\n      leadId: t.leadId ?? null,\r\n      featured: t.featured ?? false,\r\n      gradient: t.gradient ?? \"from-blue-500 to-cyan-500\",\r\n      projects: t.projects ?? 0,\r\n      completion: t.completion ?? 0,\r\n      members: [], // keep empty — frontend can call /api/users or a team-members endpoint\r\n      createdAt: t.createdAt,\r\n    }));\r\n\r\n    return NextResponse.json({ ok: true, teams: normalized });\r\n  } catch (err: any) {\r\n    console.error(\"[api/dashboard/teams] error:\", err);\r\n    return NextResponse.json({ ok: false, message: \"Server error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,uCAAuC;;;;;AACvC;AACA;;;AAMO,eAAe,IAAI,GAAY;IACpC,IAAI;QACF,MAAM,MAAM,IAAI,IAAI,IAAI,GAAG;QAC3B,MAAM,iBAAiB,IAAI,YAAY,CAAC,GAAG,CAAC,qBAAqB;QACjE,IAAI,CAAC,gBAAgB;YACnB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,IAAI;gBAAO,SAAS;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QAC5F;QAEA,iFAAiF;QACjF,MAAM,QAAQ,MAAM,gIAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;YACvC,OAAO;gBAAE;YAAe;YACxB,SAAS;gBAAE,WAAW;YAAO;YAC7B,QAAQ;gBACN,IAAI;gBACJ,MAAM;gBACN,aAAa;gBACb,QAAQ;gBACR,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,YAAY;gBACZ,WAAW;YACb;QACF;QAEA,MAAM,aAAa,MAAM,GAAG,CAAC,CAAC,IAAM,CAAC;gBACnC,IAAI,EAAE,EAAE;gBACR,MAAM,EAAE,IAAI;gBACZ,aAAa,EAAE,WAAW,IAAI;gBAC9B,QAAQ,EAAE,MAAM,IAAI;gBACpB,UAAU,EAAE,QAAQ,IAAI;gBACxB,UAAU,EAAE,QAAQ,IAAI;gBACxB,UAAU,EAAE,QAAQ,IAAI;gBACxB,YAAY,EAAE,UAAU,IAAI;gBAC5B,SAAS,EAAE;gBACX,WAAW,EAAE,SAAS;YACxB,CAAC;QAED,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,IAAI;YAAM,OAAO;QAAW;IACzD,EAAE,OAAO,KAAU;QACjB,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,IAAI;YAAO,SAAS;QAAe,GAAG;YAAE,QAAQ;QAAI;IACjF;AACF","debugId":null}}]
}
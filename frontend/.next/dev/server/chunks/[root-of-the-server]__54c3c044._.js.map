{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  // prevent multiple instantiation in dev\r\n  // eslint-disable-next-line no-var\r\n  var prisma: PrismaClient | undefined;\r\n}\r\n\r\nexport const prisma =\r\n  global.prisma ??\r\n  new PrismaClient({\r\n    log: [\"query\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAQO,MAAM,SACX,OAAO,MAAM,IACb,IAAI,6IAAY,CAAC;IACf,KAAK;QAAC;KAAQ;AAChB;AAEF,wCAA2C,OAAO,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 74, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/app/api/auth/verify-otp/route.ts"],"sourcesContent":["// src/app/api/auth/verify-otp/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport bcrypt from \"bcrypt\";\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const body = await req.json().catch(() => ({}));\r\n    const email = (body?.email || \"\").toString().trim().toLowerCase();\r\n    const code = (body?.code || \"\").toString().trim();\r\n\r\n    if (!email || !code) {\r\n      return NextResponse.json({ error: \"Email and code required\" }, { status: 400 });\r\n    }\r\n\r\n    // find the most recent OTP row for this email (if you have unique email, use findUnique)\r\n    const otpRow = await prisma.emailOtp.findFirst({\r\n      where: { email },\r\n      orderBy: { createdAt: \"desc\" },\r\n    });\r\n\r\n    if (!otpRow) {\r\n      return NextResponse.json({ error: \"No OTP found for this email\" }, { status: 404 });\r\n    }\r\n\r\n    // Optional expiry check: will only work if your model has expiresAt\r\n    if ((otpRow as any).expiresAt) {\r\n      const expiresAt = new Date((otpRow as any).expiresAt);\r\n      if (expiresAt < new Date()) {\r\n        return NextResponse.json({ error: \"OTP expired\" }, { status: 410 });\r\n      }\r\n    }\r\n\r\n    // Determine verification method:\r\n    // - If codeHash exists, use bcrypt.compare(code, codeHash)\r\n    // - Otherwise, fall back to direct plaintext comparison against otp field\r\n    const codeHash = (otpRow as any).codeHash;\r\n    const plainOtp = (otpRow as any).otp;\r\n\r\n    let verified = false;\r\n    if (codeHash) {\r\n      // defensive: ensure both args are defined\r\n      if (typeof code !== \"string\" || !codeHash) {\r\n        return NextResponse.json({ error: \"Invalid verification data\" }, { status: 400 });\r\n      }\r\n      verified = await bcrypt.compare(code, codeHash);\r\n    } else if (typeof plainOtp === \"string\") {\r\n      verified = code === plainOtp;\r\n    } else {\r\n      // neither hash nor plaintext OTP present â€” can't verify\r\n      return NextResponse.json({ error: \"Server verification misconfiguration\" }, { status: 500 });\r\n    }\r\n\r\n    if (!verified) {\r\n      return NextResponse.json({ error: \"Invalid OTP\" }, { status: 401 });\r\n    }\r\n\r\n    // mark verified (if you store verified flag)\r\n    await prisma.emailOtp.update({\r\n      where: { id: otpRow.id },\r\n      data: { verified: true },\r\n    });\r\n\r\n    // return success (you can also create a session or issue token here)\r\n    return NextResponse.json({ ok: true, message: \"Verified\" });\r\n  } catch (err) {\r\n    console.error(\"verify-otp error:\", err);\r\n    return NextResponse.json({ error: \"Server error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,uCAAuC;;;;;AACvC;AACA;AACA;;;;AAEO,eAAe,KAAK,GAAY;IACrC,IAAI;QACF,MAAM,OAAO,MAAM,IAAI,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,CAAC,CAAC;QAC7C,MAAM,QAAQ,CAAC,MAAM,SAAS,EAAE,EAAE,QAAQ,GAAG,IAAI,GAAG,WAAW;QAC/D,MAAM,OAAO,CAAC,MAAM,QAAQ,EAAE,EAAE,QAAQ,GAAG,IAAI;QAE/C,IAAI,CAAC,SAAS,CAAC,MAAM;YACnB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QAC/E;QAEA,yFAAyF;QACzF,MAAM,SAAS,MAAM,gIAAM,CAAC,QAAQ,CAAC,SAAS,CAAC;YAC7C,OAAO;gBAAE;YAAM;YACf,SAAS;gBAAE,WAAW;YAAO;QAC/B;QAEA,IAAI,CAAC,QAAQ;YACX,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA8B,GAAG;gBAAE,QAAQ;YAAI;QACnF;QAEA,oEAAoE;QACpE,IAAI,AAAC,OAAe,SAAS,EAAE;YAC7B,MAAM,YAAY,IAAI,KAAK,AAAC,OAAe,SAAS;YACpD,IAAI,YAAY,IAAI,QAAQ;gBAC1B,OAAO,gJAAY,CAAC,IAAI,CAAC;oBAAE,OAAO;gBAAc,GAAG;oBAAE,QAAQ;gBAAI;YACnE;QACF;QAEA,iCAAiC;QACjC,2DAA2D;QAC3D,0EAA0E;QAC1E,MAAM,WAAW,AAAC,OAAe,QAAQ;QACzC,MAAM,WAAW,AAAC,OAAe,GAAG;QAEpC,IAAI,WAAW;QACf,IAAI,UAAU;YACZ,0CAA0C;YAC1C,IAAI,OAAO,SAAS,YAAY,CAAC,UAAU;gBACzC,OAAO,gJAAY,CAAC,IAAI,CAAC;oBAAE,OAAO;gBAA4B,GAAG;oBAAE,QAAQ;gBAAI;YACjF;YACA,WAAW,MAAM,gHAAM,CAAC,OAAO,CAAC,MAAM;QACxC,OAAO,IAAI,OAAO,aAAa,UAAU;YACvC,WAAW,SAAS;QACtB,OAAO;YACL,wDAAwD;YACxD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAuC,GAAG;gBAAE,QAAQ;YAAI;QAC5F;QAEA,IAAI,CAAC,UAAU;YACb,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAc,GAAG;gBAAE,QAAQ;YAAI;QACnE;QAEA,6CAA6C;QAC7C,MAAM,gIAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;YAC3B,OAAO;gBAAE,IAAI,OAAO,EAAE;YAAC;YACvB,MAAM;gBAAE,UAAU;YAAK;QACzB;QAEA,qEAAqE;QACrE,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,IAAI;YAAM,SAAS;QAAW;IAC3D,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,qBAAqB;QACnC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAe,GAAG;YAAE,QAAQ;QAAI;IACpE;AACF","debugId":null}}]
}
module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/@prisma/client [external] (@prisma/client, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("@prisma/client", () => require("@prisma/client"));

module.exports = mod;
}),
"[externals]/node:http [external] (node:http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:http", () => require("node:http"));

module.exports = mod;
}),
"[externals]/node:https [external] (node:https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:https", () => require("node:https"));

module.exports = mod;
}),
"[externals]/node:zlib [external] (node:zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:zlib", () => require("node:zlib"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/node:buffer [external] (node:buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:buffer", () => require("node:buffer"));

module.exports = mod;
}),
"[externals]/node:util [external] (node:util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:util", () => require("node:util"));

module.exports = mod;
}),
"[externals]/node:process [external] (node:process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:process", () => require("node:process"));

module.exports = mod;
}),
"[externals]/node:stream/web [external] (node:stream/web, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream/web", () => require("node:stream/web"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/node:url [external] (node:url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:url", () => require("node:url"));

module.exports = mod;
}),
"[externals]/node:net [external] (node:net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:net", () => require("node:net"));

module.exports = mod;
}),
"[externals]/node:fs [external] (node:fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs", () => require("node:fs"));

module.exports = mod;
}),
"[externals]/node:path [external] (node:path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:path", () => require("node:path"));

module.exports = mod;
}),
"[externals]/worker_threads [external] (worker_threads, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("worker_threads", () => require("worker_threads"));

module.exports = mod;
}),
"[project]/src/lib/socket.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/lib/socket.ts
// Small helper to call the socket server's /emit endpoint from backend code.
// Usage:
//   import { emitToRooms } from "@/lib/socket";
//   await emitToRooms({ event: "chat:created", rooms: ["user:123","org:abc"], payload: {...} });
__turbopack_context__.s([
    "emitToRooms",
    ()=>emitToRooms
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/src/index.js [app-route] (ecmascript) <locals>");
;
const SOCKET_SERVER_URL = process.env.SOCKET_SERVER_URL || process.env.NEXT_PUBLIC_SOCKET_URL || "http://localhost:4001";
const SOCKET_SERVER_KEY = process.env.SOCKET_SERVER_KEY || "";
async function emitToRooms({ event, payload = {}, rooms, excludeSocketId, timeoutMs = 2000 }) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    if (!SOCKET_SERVER_KEY) {
        // still allow if no key supplied (not recommended for prod)
        console.warn("socket: no SOCKET_SERVER_KEY configured — /emit endpoint not protected");
    }
    const url = new URL("/emit", SOCKET_SERVER_URL).toString();
    const body = {
        key: SOCKET_SERVER_KEY,
        rooms,
        event,
        payload,
        excludeSocketId
    };
    try {
        const controller = new AbortController();
        const id = setTimeout(()=>controller.abort(), timeoutMs);
        const resp = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"])(url, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(body),
            signal: controller.signal
        });
        clearTimeout(id);
        if (!resp.ok) {
            const text = await resp.text().catch(()=>"");
            return {
                ok: false,
                status: resp.status,
                body: text
            };
        }
        const json = await resp.json().catch(()=>({}));
        return {
            ok: true,
            result: json
        };
    } catch (err) {
        return {
            ok: false,
            error: String(err?.message ?? err)
        };
    }
}
}),
"[project]/src/lib/socketAdapter.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/lib/socketAdapter.ts
// Adapter to forward legacy `global.io` / `global._io` / `global.socketServer`
// calls to the standalone socket server via the /emit HTTP endpoint.
__turbopack_context__.s([
    "socketAdapter",
    ()=>adapter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$socket$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/socket.ts [app-route] (ecmascript)");
;
function makeRoomEmitter(room) {
    return {
        emit: (event, payload)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$socket$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["emitToRooms"])({
                event,
                payload,
                rooms: room
            });
        },
        // allow io.to(room).except(socketId).emit(...) pattern
        except: (socketId)=>({
                emit: (event, payload)=>{
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$socket$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["emitToRooms"])({
                        event,
                        payload,
                        rooms: room,
                        excludeSocketId: socketId
                    });
                }
            })
    };
}
// Single shared adapter instance
const adapter = {
    /**
   * io.emit("event", payload)
   *  -> broadcast globally
   */ emit: (event, payload)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$socket$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["emitToRooms"])({
            event,
            payload
        });
    },
    /**
   * io.to("room").emit("event", payload)
   *  -> broadcast to specific room(s)
   */ to: (room)=>makeRoomEmitter(room)
};
function attachGlobals() {
    if (global.__socketAdapterInitialized) return;
    global.__socketAdapterInitialized = true;
    // These are the names used in your API code:
    // (global as any).io || (global as any)._io || (global as any).socketServer
    const g = global;
    if (!g.io) g.io = adapter;
    if (!g._io) g._io = adapter;
    if (!g.socketServer) g.socketServer = adapter;
}
// Run immediately on import (server-only)
attachGlobals();
;
}),
"[project]/src/lib/prisma.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// lib/prisma.ts
__turbopack_context__.s([
    "prisma",
    ()=>prisma
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/@prisma/client [external] (@prisma/client, cjs)");
// near the top, before exports
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$socketAdapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/socketAdapter.ts [app-route] (ecmascript)");
;
;
const prisma = global.__prisma__ ?? new __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["PrismaClient"]({
    log: ("TURBOPACK compile-time truthy", 1) ? [
        "query",
        "warn",
        "error"
    ] : "TURBOPACK unreachable"
});
if ("TURBOPACK compile-time truthy", 1) global.__prisma__ = prisma;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[project]/src/lib/jwt.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/lib/jwt.ts
__turbopack_context__.s([
    "signSession",
    ()=>signSession,
    "signTemp",
    ()=>signTemp,
    "verifySession",
    ()=>verifySession,
    "verifyTemp",
    ()=>verifyTemp
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jsonwebtoken/index.js [app-route] (ecmascript)");
;
const SECRET = process.env.JWT_SECRET;
if (!SECRET) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        console.warn("[JWT] Using fallback secret for development");
    }
}
function signTemp(payload, expiresIn = "15m") {
    const safePayload = {
        ...payload
    };
    delete safePayload.exp;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].sign(safePayload, SECRET, {
        expiresIn
    });
}
function verifyTemp(token) {
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].verify(token, SECRET);
    } catch (err) {
        console.warn("[JWT] verifyTemp failed:", err.message);
        return null;
    }
}
function signSession(payload, expiresIn = "7d") {
    const safePayload = {
        ...payload
    };
    delete safePayload.exp;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].sign(safePayload, SECRET, {
        expiresIn
    });
}
function verifySession(token) {
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonwebtoken$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].verify(token, SECRET);
    } catch (err) {
        console.warn("[JWT] verifySession failed:", err.message);
        return null;
    }
}
}),
"[project]/src/lib/auth.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/lib/auth.ts
__turbopack_context__.s([
    "getSessionUser",
    ()=>getSessionUser
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/prisma.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$jwt$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/jwt.ts [app-route] (ecmascript)");
;
;
async function getSessionUser(req) {
    try {
        // 1️⃣ Prefer Authorization header: "Bearer <token>"
        let token = null;
        const authHeader = req.headers.get("authorization");
        if (authHeader?.startsWith("Bearer ")) {
            token = authHeader.slice("Bearer ".length).trim();
        }
        // 2️⃣ Fallback to cookies
        if (!token) {
            const cookieHeader = req.headers.get("cookie") || "";
            const cookies = Object.fromEntries(cookieHeader.split(";").map((c)=>c.trim().split("=")).map(([k, v])=>[
                    decodeURIComponent(k),
                    decodeURIComponent(v)
                ]));
            token = cookies["session"] || cookies["token"] || null;
        }
        if (!token) return null;
        // 3️⃣ Verify token safely
        const payload = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$jwt$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifySession"])(token);
        if (!payload?.id) return null;
        // 4️⃣ Fetch user from DB
        const user = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].user.findUnique({
            where: {
                id: payload.id
            }
        });
        if (!user) return null;
        return {
            id: user.id,
            email: user.email ?? null,
            role: user.role,
            organizationId: user.organizationId
        };
    } catch (err) {
        console.warn("[getSessionUser] error:", err?.message || err);
        return null;
    }
}
}),
"[project]/src/app/api/teams/[id]/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/app/api/teams/[id]/route.ts
__turbopack_context__.s([
    "DELETE",
    ()=>DELETE,
    "GET",
    ()=>GET,
    "PUT",
    ()=>PUT
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/prisma.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/auth.ts [app-route] (ecmascript)"); // optional helper; if absent make sure it's a noop or remove
;
;
;
/**
 * Route: /api/teams/[id]
 *
 * Handlers:
 *  - GET    -> fetch team (with manager + members)
 *  - PUT    -> update team fields and (optionally) replace members (keeps chat members in sync)
 *  - DELETE -> delete team and its members (attempts to cleanup related chat)
 *
 * Notes:
 *  - In App Router handlers the `params` argument can be a Promise; always `await params`.
 *  - Defensive: when Prisma doesn't have optional UI fields, it retries without them.
 */ /* ----------------- Helpers ----------------- */ function jsonError(message, status = 400) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        ok: false,
        message
    }, {
        status
    });
}
async function resolveSessionOrganizationId(req) {
    try {
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getSessionUser"] === "function") {
            const session = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getSessionUser"](req).catch(()=>null);
            if (session?.organizationId) return String(session.organizationId);
        }
    } catch (e) {
        // swallow session helper errors
        console.warn("[api/teams/[id]] getSessionUser error:", e?.message ?? e);
    }
    return null;
}
function isValidId(v) {
    return typeof v === "string" && v.trim().length > 0;
}
/**
 * Map User.role (Role enum) -> ChatMember.role (ChatRole enum)
 * ChatRole values: "MEMBER" | "MANAGER" | "ADMIN"
 * We only assign MANAGER for managers; admins handled separately (admins should not be added as ChatMember in team chats).
 */ function mapUserRoleToChatRole(userRole) {
    if (userRole === "MANAGER") return "MANAGER";
    // other roles (ADMIN, EMPLOYEE) map to MEMBER for chat membership purposes; ADMIN will be handled specially
    return "MEMBER";
}
async function GET(req, context) {
    try {
        const paramsResolved = await context.params;
        const id = paramsResolved?.id;
        if (!isValidId(id)) return jsonError("Missing team id", 400);
        const team = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].team.findUnique({
            where: {
                id
            },
            include: {
                manager: {
                    select: {
                        id: true,
                        name: true,
                        email: true,
                        role: true
                    }
                },
                members: {
                    select: {
                        id: true,
                        role: true,
                        user: {
                            select: {
                                id: true,
                                name: true,
                                email: true
                            }
                        }
                    }
                }
            }
        });
        if (!team) return jsonError("Team not found", 404);
        // normalize shape for frontend (keeps returned object predictable)
        const response = {
            id: team.id,
            name: team.name,
            description: team.description ?? null,
            managerId: team.managerId ?? null,
            manager: team.manager ? {
                id: team.manager.id,
                name: team.manager.name,
                email: team.manager.email
            } : null,
            // optional UI metadata (only present if schema defines them)
            featured: team.featured ?? false,
            gradient: team.gradient ?? null,
            projects: typeof team.projects !== "undefined" ? Number(team.projects ?? 0) : null,
            completion: typeof team.completion !== "undefined" ? Number(team.completion ?? 0) : null,
            members: (team.members ?? []).map((m)=>({
                    teamMemberId: m.id,
                    userId: m.user?.id ?? null,
                    name: m.user?.name ?? null,
                    email: m.user?.email ?? null,
                    role: m.role ?? null
                })),
            organizationId: team.organizationId,
            createdAt: team.createdAt?.toISOString?.() ?? null,
            updatedAt: team.updatedAt?.toISOString?.() ?? null
        };
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: true,
            team: response
        }, {
            status: 200
        });
    } catch (err) {
        console.error("[api/teams/[id]][GET] error:", err);
        const isDev = ("TURBOPACK compile-time value", "development") !== "production";
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: false,
            message: ("TURBOPACK compile-time truthy", 1) ? err?.message || String(err) : "TURBOPACK unreachable"
        }, {
            status: 500
        });
    }
}
async function PUT(req, context) {
    try {
        const paramsResolved = await context.params;
        const id = paramsResolved?.id;
        if (!isValidId(id)) return jsonError("Missing team id", 400);
        const body = await req.json().catch(()=>({})) ?? {};
        const { name, description = undefined, managerId = undefined, memberUserIds = undefined, // optional UI metadata that UI may send (only set if provided)
        featured = undefined, gradient = undefined, projects = undefined, completion = undefined } = body;
        // optional session org check
        const sessionOrg = await resolveSessionOrganizationId(req);
        // load team and ensure it exists
        const existing = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].team.findUnique({
            where: {
                id
            },
            select: {
                id: true,
                organizationId: true
            }
        });
        if (!existing) return jsonError("Team not found", 404);
        if (sessionOrg && existing.organizationId !== sessionOrg) return jsonError("Unauthorized for this organization", 403);
        // validate managerId (if provided)
        if (managerId !== undefined) {
            if (managerId !== null && !isValidId(managerId)) return jsonError("Invalid managerId", 400);
            if (managerId) {
                const mgr = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].user.findUnique({
                    where: {
                        id: managerId
                    },
                    select: {
                        id: true,
                        organizationId: true
                    }
                });
                if (!mgr) return jsonError("Manager user not found", 404);
                if (mgr.organizationId !== existing.organizationId) return jsonError("Manager must belong to same organization", 400);
            }
        }
        // validate memberUserIds (if provided)
        let memberIds = null;
        if (memberUserIds !== undefined) {
            if (!Array.isArray(memberUserIds)) return jsonError("memberUserIds must be an array", 400);
            memberIds = Array.from(new Set(memberUserIds.filter((v)=>typeof v === "string")));
            if (memberIds.length > 0) {
                const users = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].user.findMany({
                    where: {
                        id: {
                            in: memberIds
                        }
                    },
                    select: {
                        id: true,
                        organizationId: true
                    }
                });
                const found = new Set(users.map((u)=>u.id));
                for (const uid of memberIds){
                    if (!found.has(uid)) return jsonError(`Member user not found: ${uid}`, 404);
                }
                for (const u of users){
                    if (u.organizationId !== existing.organizationId) return jsonError("All member users must belong to the same organization", 400);
                }
            }
        }
        // Build update data (only include properties that were provided)
        const updateDataCandidate = {};
        if (name !== undefined) updateDataCandidate.name = String(name).trim();
        if (description !== undefined) updateDataCandidate.description = description === null ? null : String(description).trim();
        if (managerId !== undefined) {
            // manager relation update: connect or disconnect
            if (managerId) updateDataCandidate.manager = {
                connect: {
                    id: managerId
                }
            };
            else updateDataCandidate.manager = {
                disconnect: true
            };
        }
        // include optional UI metadata if provided by client
        if (featured !== undefined) updateDataCandidate.featured = featured;
        if (gradient !== undefined) updateDataCandidate.gradient = gradient;
        if (projects !== undefined) updateDataCandidate.projects = typeof projects === "number" ? projects : Number(projects ?? 0);
        if (completion !== undefined) updateDataCandidate.completion = typeof completion === "number" ? completion : Number(completion ?? 0);
        // Attempt update in transaction. Because some Prisma schemas may NOT have the optional UI fields,
        // we try once with the full update data; if Prisma complains about unknown fields (validation error),
        // we retry without the optional UI fields.
        let transactionResult = null;
        try {
            transactionResult = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].$transaction(async (tx)=>{
                const updatedTeam = await tx.team.update({
                    where: {
                        id
                    },
                    data: updateDataCandidate,
                    select: {
                        id: true,
                        name: true,
                        description: true,
                        organizationId: true,
                        managerId: true
                    }
                });
                let members = [];
                if (memberIds !== null) {
                    // replace members: delete then createMany (skipDuplicates for safety)
                    await tx.teamMember.deleteMany({
                        where: {
                            teamId: id
                        }
                    });
                    if (memberIds.length > 0) {
                        const createManyData = memberIds.map((uid)=>({
                                teamId: id,
                                userId: uid,
                                role: "EMPLOYEE"
                            }));
                        await tx.teamMember.createMany({
                            data: createManyData,
                            skipDuplicates: true
                        });
                        members = await tx.teamMember.findMany({
                            where: {
                                teamId: id
                            },
                            select: {
                                id: true,
                                role: true,
                                user: {
                                    select: {
                                        id: true,
                                        name: true,
                                        email: true
                                    }
                                }
                            }
                        });
                    }
                } else {
                    // not replacing members => return existing members
                    members = await tx.teamMember.findMany({
                        where: {
                            teamId: id
                        },
                        select: {
                            id: true,
                            role: true,
                            user: {
                                select: {
                                    id: true,
                                    name: true,
                                    email: true
                                }
                            }
                        }
                    });
                }
                return {
                    team: updatedTeam,
                    members
                };
            });
        } catch (err) {
            // detect Prisma unknown argument/validation error and retry without optional UI fields
            const message = String(err?.message || err);
            const unknownArg = /Unknown argument[s]?\s+`?(featured|gradient|projects|completion)`?/i.test(message) || /Unknown arg/i.test(message);
            if (unknownArg) {
                // remove optional UI keys and retry
                const safeUpdateData = {
                    ...updateDataCandidate
                };
                delete safeUpdateData.featured;
                delete safeUpdateData.gradient;
                delete safeUpdateData.projects;
                delete safeUpdateData.completion;
                transactionResult = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].$transaction(async (tx)=>{
                    const updatedTeam = await tx.team.update({
                        where: {
                            id
                        },
                        data: safeUpdateData,
                        select: {
                            id: true,
                            name: true,
                            description: true,
                            organizationId: true,
                            managerId: true
                        }
                    });
                    let members = [];
                    if (memberIds !== null) {
                        await tx.teamMember.deleteMany({
                            where: {
                                teamId: id
                            }
                        });
                        if (memberIds.length > 0) {
                            const createManyData = memberIds.map((uid)=>({
                                    teamId: id,
                                    userId: uid,
                                    role: "EMPLOYEE"
                                }));
                            await tx.teamMember.createMany({
                                data: createManyData,
                                skipDuplicates: true
                            });
                            members = await tx.teamMember.findMany({
                                where: {
                                    teamId: id
                                },
                                select: {
                                    id: true,
                                    role: true,
                                    user: {
                                        select: {
                                            id: true,
                                            name: true,
                                            email: true
                                        }
                                    }
                                }
                            });
                        }
                    } else {
                        members = await tx.teamMember.findMany({
                            where: {
                                teamId: id
                            },
                            select: {
                                id: true,
                                role: true,
                                user: {
                                    select: {
                                        id: true,
                                        name: true,
                                        email: true
                                    }
                                }
                            }
                        });
                    }
                    return {
                        team: updatedTeam,
                        members
                    };
                });
            } else {
                // rethrow other errors
                throw err;
            }
        }
        // load full team for response (includes manager and members)
        const teamFull = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].team.findUnique({
            where: {
                id
            },
            include: {
                manager: {
                    select: {
                        id: true,
                        name: true,
                        email: true
                    }
                },
                members: {
                    select: {
                        id: true,
                        role: true,
                        user: {
                            select: {
                                id: true,
                                name: true,
                                email: true
                            }
                        }
                    }
                }
            }
        });
        if (!teamFull) return jsonError("Team not found after update (unexpected)", 500);
        const response = {
            id: teamFull.id,
            name: teamFull.name,
            description: teamFull.description ?? null,
            manager: teamFull.manager ? {
                id: teamFull.manager.id,
                name: teamFull.manager.name,
                email: teamFull.manager.email
            } : null,
            // optional meta (present only if schema supports them)
            featured: teamFull.featured ?? false,
            gradient: teamFull.gradient ?? null,
            projects: typeof teamFull.projects !== "undefined" ? Number(teamFull.projects ?? 0) : null,
            completion: typeof teamFull.completion !== "undefined" ? Number(teamFull.completion ?? 0) : null,
            members: (teamFull.members ?? []).map((m)=>({
                    teamMemberId: m.id,
                    userId: m.user?.id ?? null,
                    name: m.user?.name ?? null,
                    email: m.user?.email ?? null,
                    role: m.role ?? null
                })),
            organizationId: teamFull.organizationId,
            createdAt: teamFull.createdAt?.toISOString?.() ?? null,
            updatedAt: teamFull.updatedAt?.toISOString?.() ?? null
        };
        // -----------------------------
        // CHAT SYNC (best-effort): if the team has a group chat, sync chat members to match team membership
        // -----------------------------
        (async ()=>{
            try {
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chat || !__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chatMember) {
                    // Chat model not present; nothing to do
                    return;
                }
                // find chat for this team (assumes chat.teamId relation exists)
                const teamChat = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chat.findFirst({
                    where: {
                        teamId: id
                    },
                    select: {
                        id: true,
                        organizationId: true,
                        name: true
                    }
                });
                if (!teamChat) {
                    // no chat for this team; nothing to sync
                    return;
                }
                const chatId = teamChat.id;
                // Build the intended set of userIds for the chat: manager + members (do NOT include org admins)
                const intended = new Set();
                if (teamFull.manager?.id) intended.add(teamFull.manager.id);
                for (const m of teamFull.members ?? []){
                    if (m.userId) intended.add(m.userId);
                }
                // fetch existing chat members (include role so we can handle admin rows)
                const existingChatMembers = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chatMember.findMany({
                    where: {
                        chatId
                    },
                    select: {
                        id: true,
                        userId: true,
                        role: true
                    }
                });
                // Enforce invariant: admins should not be present in ChatMember for team chats.
                const adminRows = existingChatMembers.filter((cm)=>String(cm.role).toUpperCase() === "ADMIN");
                if (adminRows.length > 0) {
                    const adminRowIds = adminRows.map((r)=>r.id);
                    try {
                        await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chatMember.deleteMany({
                            where: {
                                id: {
                                    in: adminRowIds
                                }
                            }
                        });
                        // emit removal events for admins removed (best-effort)
                        try {
                            const io = /*TURBOPACK member replacement*/ __turbopack_context__.g.io || /*TURBOPACK member replacement*/ __turbopack_context__.g._io || /*TURBOPACK member replacement*/ __turbopack_context__.g.socketServer;
                            if (io && typeof io.to === "function") {
                                for (const r of adminRows){
                                    io.to(`user:${r.userId}`).emit("chat:member:removed", {
                                        chatId,
                                        userId: r.userId
                                    });
                                }
                                io.to(`chat:${chatId}`).emit("chat:member:list:updated", {
                                    chatId
                                });
                            }
                        } catch (e) {
                        // ignore emit failures
                        }
                    } catch (e) {
                        console.warn("[api/teams] failed to remove admin ChatMember rows (non-fatal):", e);
                    }
                }
                const existingUserIds = new Set(existingChatMembers.map((cm)=>cm.userId));
                // Determine additions and removals (after admin cleanup)
                const toAdd = Array.from(intended).filter((uid)=>!existingUserIds.has(uid));
                const toRemove = existingChatMembers.filter((cm)=>!intended.has(cm.userId));
                // Remove chat members that are no longer part of the team
                if (toRemove.length > 0) {
                    const removeIds = toRemove.map((r)=>r.id);
                    await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chatMember.deleteMany({
                        where: {
                            id: {
                                in: removeIds
                            }
                        }
                    });
                    // emit removed events
                    try {
                        const io = /*TURBOPACK member replacement*/ __turbopack_context__.g.io || /*TURBOPACK member replacement*/ __turbopack_context__.g._io || /*TURBOPACK member replacement*/ __turbopack_context__.g.socketServer;
                        if (io && typeof io.to === "function") {
                            for (const r of toRemove){
                                io.to(`user:${r.userId}`).emit("chat:member:removed", {
                                    chatId,
                                    userId: r.userId
                                });
                            }
                            io.to(`chat:${chatId}`).emit("chat:member:list:updated", {
                                chatId
                            });
                        }
                    } catch (e) {
                        console.warn("[api/teams] chat:member:removed emit failed:", e);
                    }
                }
                // Add new chat members (skip org admins)
                if (toAdd.length > 0) {
                    // Filter out org admins from toAdd (admins should not be chat members)
                    const usersForAdd = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].user.findMany({
                        where: {
                            id: {
                                in: toAdd
                            }
                        },
                        select: {
                            id: true,
                            role: true
                        }
                    });
                    const filteredUsersForAdd = usersForAdd.filter((u)=>String(u.role).toUpperCase() !== "ADMIN");
                    const chatMemberRows = filteredUsersForAdd.map((u)=>({
                            chatId,
                            userId: u.id,
                            role: mapUserRoleToChatRole(u.role)
                        }));
                    if (chatMemberRows.length > 0) {
                        await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chatMember.createMany({
                            data: chatMemberRows,
                            skipDuplicates: true
                        });
                    }
                    // emit added events
                    try {
                        const io = /*TURBOPACK member replacement*/ __turbopack_context__.g.io || /*TURBOPACK member replacement*/ __turbopack_context__.g._io || /*TURBOPACK member replacement*/ __turbopack_context__.g.socketServer;
                        if (io && typeof io.to === "function") {
                            for (const u of filteredUsersForAdd){
                                io.to(`user:${u.id}`).emit("chat:member:added", {
                                    chatId,
                                    user: {
                                        id: u.id,
                                        role: mapUserRoleToChatRole(u.role)
                                    }
                                });
                            }
                            io.to(`chat:${chatId}`).emit("chat:member:list:updated", {
                                chatId
                            });
                        }
                    } catch (e) {
                        console.warn("[api/teams] chat:member:added emit failed:", e);
                    }
                }
            } catch (syncErr) {
                console.warn("[api/teams] chat sync failed (non-fatal):", syncErr);
            }
        })();
        // Emit team updated event to org room (best-effort)
        (async ()=>{
            try {
                const io = /*TURBOPACK member replacement*/ __turbopack_context__.g.io || /*TURBOPACK member replacement*/ __turbopack_context__.g._io || /*TURBOPACK member replacement*/ __turbopack_context__.g.socketServer;
                if (io && typeof io.to === "function") {
                    io.to(`org:${response.organizationId}`).emit("team:updated", {
                        team: response
                    });
                } else if (io && typeof io.emit === "function") {
                    io.emit("team:updated", {
                        team: response
                    });
                }
            } catch (e) {
                console.warn("[api/teams] team:updated emit failed:", e);
            }
        })();
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: true,
            team: response
        }, {
            status: 200
        });
    } catch (err) {
        console.error("[api/teams/[id]][PUT] error:", err);
        const isDev = ("TURBOPACK compile-time value", "development") !== "production";
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: false,
            message: ("TURBOPACK compile-time truthy", 1) ? err?.message || String(err) : "TURBOPACK unreachable"
        }, {
            status: 500
        });
    }
}
async function DELETE(req, context) {
    try {
        const paramsResolved = await context.params;
        const id = paramsResolved?.id;
        if (!isValidId(id)) return jsonError("Missing team id", 400);
        const sessionOrg = await resolveSessionOrganizationId(req);
        const team = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].team.findUnique({
            where: {
                id
            },
            select: {
                id: true,
                organizationId: true
            }
        });
        if (!team) return jsonError("Team not found", 404);
        if (sessionOrg && team.organizationId !== sessionOrg) return jsonError("Unauthorized for this organization", 403);
        // Delete members then team to avoid FK problems
        // Delete members then team to avoid FK problems (idempotent)
        try {
            const txResult = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].$transaction(async (tx)=>{
                // remove team members (safe)
                await tx.teamMember.deleteMany({
                    where: {
                        teamId: id
                    }
                });
                // attempt to delete the team without throwing if already missing
                const deleted = await tx.team.deleteMany({
                    where: {
                        id
                    }
                });
                return {
                    deletedCount: deleted.count ?? 0
                };
            });
            if ((txResult?.deletedCount ?? 0) === 0) {
                // Team was not present (already deleted) -> return 404 to the client
                return jsonError("Team not found", 404);
            }
        } catch (e) {
            // if anything unexpected happens, log and propagate to outer handler
            console.error("[api/teams/[id]][DELETE] transaction failed:", e);
            throw e;
        }
        // best-effort: cleanup or archive the related chat for this team
        (async ()=>{
            try {
                if (__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chat) {
                    const teamChat = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chat.findFirst({
                        where: {
                            teamId: id
                        },
                        select: {
                            id: true
                        }
                    });
                    if (teamChat) {
                        // try delete chat members and chat itself (non-fatal)
                        try {
                            if (__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chatMember) {
                                await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chatMember.deleteMany({
                                    where: {
                                        chatId: teamChat.id
                                    }
                                });
                            }
                        } catch (e) {
                            console.warn("[api/teams] cleaning chat members failed:", e);
                        }
                        try {
                            // if schema supports "archived" field prefer archiving instead of delete
                            if (__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chat.update) {
                                // attempt archive if field exists
                                try {
                                    await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chat.update({
                                        where: {
                                            id: teamChat.id
                                        },
                                        data: {
                                            archived: true
                                        }
                                    });
                                } catch (e) {
                                    // no archived field — fallback to delete
                                    await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].chat.delete({
                                        where: {
                                            id: teamChat.id
                                        }
                                    });
                                }
                            }
                        } catch (e) {
                            console.warn("[api/teams] deleting/archiving chat failed:", e);
                        }
                        // emit removal event
                        try {
                            const io = /*TURBOPACK member replacement*/ __turbopack_context__.g.io || /*TURBOPACK member replacement*/ __turbopack_context__.g._io || /*TURBOPACK member replacement*/ __turbopack_context__.g.socketServer;
                            if (io && typeof io.to === "function") {
                                io.to(`org:${team.organizationId}`).emit("team:deleted", {
                                    teamId: id,
                                    chatId: teamChat.id
                                });
                                io.to(`chat:${teamChat.id}`).emit("chat:archived", {
                                    chatId: teamChat.id
                                });
                            } else if (io && typeof io.emit === "function") {
                                io.emit("team:deleted", {
                                    teamId: id,
                                    chatId: teamChat.id
                                });
                            }
                        } catch (e) {
                            console.warn("[api/teams] emit after chat cleanup failed:", e);
                        }
                    }
                }
            } catch (cleanupErr) {
                console.warn("[api/teams] best-effort chat cleanup failed:", cleanupErr);
            }
        })();
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: true,
            message: "Team deleted"
        }, {
            status: 200
        });
    } catch (err) {
        console.error("[api/teams/[id]][DELETE] error:", err);
        const isDev = ("TURBOPACK compile-time value", "development") !== "production";
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: false,
            message: ("TURBOPACK compile-time truthy", 1) ? err?.message || String(err) : "TURBOPACK unreachable"
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__e9d0e2be._.js.map
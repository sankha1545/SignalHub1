{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  // prevent multiple instantiation in dev\r\n  // eslint-disable-next-line no-var\r\n  var prisma: PrismaClient | undefined;\r\n}\r\n\r\nexport const prisma =\r\n  global.prisma ??\r\n  new PrismaClient({\r\n    log: [\"query\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAQO,MAAM,SACX,OAAO,MAAM,IACb,IAAI,6IAAY,CAAC;IACf,KAAK;QAAC;KAAQ;AAChB;AAEF,wCAA2C,OAAO,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 98, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/auth.ts"],"sourcesContent":["// src/lib/auth.ts\r\nimport bcrypt from \"bcrypt\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport { prisma } from \"./prisma\";\r\nimport type { NextRequest } from \"next/server\";\r\n\r\nconst JWT_SECRET =\r\n  process.env.SESSION_SECRET ||\r\n  process.env.NEXTAUTH_SECRET ||\r\n  process.env.JWT_SECRET ||\r\n  \"dev-secret\";\r\n\r\nconst COOKIE_CANDIDATES = [\"session\", \"token\", \"auth_token\", \"authToken\", \"auth\"];\r\n\r\n/**\r\n * Sign a JWT for a user.\r\n * - If payload contains an `id`, it will be copied to `sub` (standard JWT subject claim).\r\n * - We keep `email` and `role` if provided.\r\n * - expiresIn follows jsonwebtoken format (\"7d\", \"1h\", etc).\r\n */\r\nexport function signToken(payload: Record<string, any>, expiresIn = \"7d\"): string {\r\n  const finalPayload: Record<string, any> = { ...payload };\r\n\r\n  // Prefer canonical claim `sub` for user id\r\n  if (!finalPayload.sub) {\r\n    if (finalPayload.id) finalPayload.sub = finalPayload.id;\r\n    else if (finalPayload.userId) finalPayload.sub = finalPayload.userId;\r\n  }\r\n\r\n  // Remove redundant id/userId if present to reduce confusion (optional)\r\n  // keep email and role as-is\r\n  return jwt.sign(finalPayload, JWT_SECRET, { expiresIn });\r\n}\r\n\r\n/** Verify token and return payload or null if invalid/expired. */\r\nexport function verifyToken(token: string): any | null {\r\n  try {\r\n    return jwt.verify(token, JWT_SECRET) as any;\r\n  } catch (err) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.debug(\"[auth] verifyToken failed:\", (err as Error)?.message ?? err);\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n/* -------------------------- Password utilities --------------------------- */\r\n\r\n/** Hash a plain password (bcrypt). */\r\nexport async function hashPassword(password: string): Promise<string> {\r\n  const saltRounds = Number(process.env.BCRYPT_SALT_ROUNDS ?? 10);\r\n  return bcrypt.hash(password, saltRounds);\r\n}\r\n\r\n/** Verify a password against a bcrypt hash. */\r\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\r\n  try {\r\n    return bcrypt.compare(password, hash);\r\n  } catch (err) {\r\n    if (process.env.NODE_ENV !== \"production\") console.error(\"[auth] verifyPassword error:\", err);\r\n    return false;\r\n  }\r\n}\r\n\r\n/* --------------------------- Session utilities --------------------------- */\r\n\r\n/**\r\n * Read token from Authorization header (Bearer) or a list of well-known cookies.\r\n * Returns a user object { id, email, name, role } fetched from DB, or null.\r\n *\r\n * Accepts a NextRequest (as used in Next.js route handlers / middleware).\r\n */\r\nexport async function getUserFromRequest(req: NextRequest) {\r\n  try {\r\n    // 1) Authorization header (Bearer)\r\n    const authHeader = req.headers.get(\"authorization\");\r\n    if (authHeader?.startsWith(\"Bearer \")) {\r\n      const token = authHeader.slice(7).trim();\r\n      const payload = verifyToken(token);\r\n      if (payload) {\r\n        const userId = payload.sub ?? payload.id ?? payload.userId ?? payload.uid;\r\n        if (userId) {\r\n          const user = await prisma.user.findUnique({\r\n            where: { id: String(userId) },\r\n            select: { id: true, email: true, name: true, role: true },\r\n          });\r\n          if (user) return user;\r\n        }\r\n      } else if (process.env.NODE_ENV !== \"production\") {\r\n        console.debug(\"[auth] bearer token present but failed verification\");\r\n      }\r\n    }\r\n\r\n    // 2) Cookies\r\n    // Try the candidate cookie names in order and return the first user matched.\r\n    for (const name of COOKIE_CANDIDATES) {\r\n      // NextRequest exposes cookies via req.cookies.get(name)\r\n      try {\r\n        const cookie = req.cookies.get(name);\r\n        if (!cookie) {\r\n          if (process.env.NODE_ENV !== \"production\") console.debug(`[auth] cookie probe: ${name} => <missing>`);\r\n          continue;\r\n        }\r\n\r\n        const token = cookie.value;\r\n        if (!token) continue;\r\n\r\n        const payload = verifyToken(token);\r\n        if (!payload) {\r\n          if (process.env.NODE_ENV !== \"production\") console.debug(`[auth] cookie ${name} token failed verify/expired`);\r\n          continue;\r\n        }\r\n\r\n        const userId = payload.sub ?? payload.id ?? payload.userId ?? payload.uid;\r\n        if (!userId) {\r\n          if (process.env.NODE_ENV !== \"production\") console.debug(`[auth] cookie ${name} token missing id/sub/userId/uid`);\r\n          continue;\r\n        }\r\n\r\n        const user = await prisma.user.findUnique({\r\n          where: { id: String(userId) },\r\n          select: { id: true, email: true, name: true, role: true },\r\n        });\r\n\r\n        if (user) {\r\n          if (process.env.NODE_ENV !== \"production\") console.debug(`[auth] cookie ${name} matched user id ${user.id}`);\r\n          return user;\r\n        } else {\r\n          if (process.env.NODE_ENV !== \"production\") console.debug(`[auth] cookie ${name} decoded id ${userId} not found`);\r\n        }\r\n      } catch (err) {\r\n        // Some runtimes may throw on req.cookies access — continue to next candidate\r\n        if (process.env.NODE_ENV !== \"production\") console.debug(`[auth] cookie probe error for ${name}:`, err);\r\n      }\r\n    }\r\n\r\n    // nothing matched\r\n    return null;\r\n  } catch (err) {\r\n    console.error(\"[auth] getUserFromRequest error:\", err);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Require authenticated user and optional allowedRoles list.\r\n * Throws a Next.js Response if unauthorized/forbidden so it can be used in route handlers:\r\n *\r\n *   const user = await requireRole(req, [\"ADMIN\"]);\r\n */\r\nexport async function requireRole(req: NextRequest, allowedRoles: string[] = []) {\r\n  const user = await getUserFromRequest(req);\r\n  if (!user) throw new Response(\"Unauthorized\", { status: 401 });\r\n  if (allowedRoles.length && !allowedRoles.includes(user.role)) {\r\n    throw new Response(\"Forbidden\", { status: 403 });\r\n  }\r\n  return user;\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 258, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/app/api/auth/login/route.ts"],"sourcesContent":["// src/app/api/auth/login/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport {prisma} from \"@/lib/prisma\"; // default export expected\r\nimport { verifyPassword, signToken } from \"@/lib/auth\";\r\n\r\n/**\r\n * Builds a secure cookie string for JWT token.\r\n */\r\nfunction buildCookie(token: string) {\r\n  const maxAge = 7 * 24 * 60 * 60; // 7 days\r\n  const secure = process.env.NODE_ENV === \"production\";\r\n  return [\r\n    `token=${token}`,\r\n    \"Path=/\",\r\n    \"HttpOnly\",\r\n    \"SameSite=Strict\",\r\n    `Max-Age=${maxAge}`,\r\n    secure ? \"Secure\" : \"\",\r\n  ]\r\n    .filter(Boolean)\r\n    .join(\"; \");\r\n}\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const { email: rawEmail, password } = await req.json();\r\n    const email = (rawEmail || \"\").toString().trim().toLowerCase();\r\n\r\n    if (!email || !password) {\r\n      return NextResponse.json(\r\n        { error: \"Email and password are required.\" },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // 1️⃣ Find the user strictly by normalized email\r\n    const user = await prisma.user.findUnique({\r\n      where: { email },\r\n      select: {\r\n        id: true,\r\n        email: true,\r\n        name: true,\r\n        passwordHash: true,\r\n        role: true,\r\n        provider: true,\r\n      },\r\n    });\r\n\r\n    // 2️⃣ Validate existence\r\n    if (!user) {\r\n      return NextResponse.json(\r\n        { error: \"Invalid email or password.\" },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // 3️⃣ Block credential login for OAuth-only accounts\r\n    if (user.provider && user.provider !== \"credentials\") {\r\n      return NextResponse.json(\r\n        {\r\n          error: `This account was created using ${user.provider}. Please sign in with ${user.provider} instead.`,\r\n        },\r\n        { status: 403 }\r\n      );\r\n    }\r\n\r\n    // 4️⃣ Ensure password hash exists\r\n    if (!user.passwordHash) {\r\n      return NextResponse.json(\r\n        { error: \"Password not set for this account.\" },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // 5️⃣ Verify password using bcrypt (verifyPassword imported from lib/auth)\r\n    const valid = await verifyPassword(password, user.passwordHash);\r\n    if (!valid) {\r\n      return NextResponse.json(\r\n        { error: \"Invalid email or password.\" },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // 6️⃣ Sign JWT token containing full user claims (for RBAC)\r\n    const token = signToken(\r\n      {\r\n        id: user.id,\r\n        email: user.email,\r\n        role: user.role, // dynamically from DB\r\n      },\r\n      \"7d\"\r\n    );\r\n\r\n    // 7️⃣ Log login event (non-blocking)\r\n    (async () => {\r\n      try {\r\n        await prisma.activityLog.create({\r\n          data: {\r\n            userId: user.id,\r\n            type: \"LOGIN\",\r\n            meta: {\r\n              provider: \"credentials\",\r\n              ts: new Date().toISOString(),\r\n            },\r\n          },\r\n        });\r\n      } catch (err) {\r\n        console.error(\"⚠️ Failed to record login activity:\", err);\r\n      }\r\n    })();\r\n\r\n    // 8️⃣ Return successful login with Set-Cookie header\r\n    const res = NextResponse.json({\r\n      ok: true,\r\n      user: {\r\n        id: user.id,\r\n        email: user.email,\r\n        name: user.name,\r\n        role: user.role,\r\n        provider: user.provider,\r\n      },\r\n    });\r\n\r\n    res.headers.set(\"Set-Cookie\", buildCookie(token));\r\n\r\n    return res;\r\n  } catch (err) {\r\n    console.error(\"❌ Login error:\", err);\r\n    return NextResponse.json(\r\n      { error: \"Internal server error.\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}
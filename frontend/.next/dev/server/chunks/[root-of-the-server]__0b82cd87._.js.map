{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/prisma.ts"],"sourcesContent":["// lib/prisma.ts\r\nimport { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line\r\n  var __prisma__: PrismaClient | undefined;\r\n}\r\nexport const prisma =\r\n  global.__prisma__ ??\r\n  new PrismaClient({\r\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"warn\", \"error\"] : [\"error\"],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== \"production\") global.__prisma__ = prisma;\r\n"],"names":[],"mappings":"AAAA,gBAAgB;;;;;AAChB;;AAMO,MAAM,SACX,OAAO,UAAU,IACjB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAQ;KAAQ,GAAG;AAC7E;AAEF,wCAA2C,OAAO,UAAU,GAAG","debugId":null}},
    {"offset": {"line": 95, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/jwt.ts"],"sourcesContent":["// src/lib/jwt.ts\r\nimport jwt, { JwtPayload } from \"jsonwebtoken\";\r\n\r\nconst SECRET = process.env.JWT_SECRET;\r\nif (!SECRET) {\r\n  if (process.env.NODE_ENV === \"production\") {\r\n    throw new Error(\"JWT_SECRET environment variable must be set in production!\");\r\n  } else {\r\n    console.warn(\"[JWT] Using fallback secret for development\");\r\n  }\r\n}\r\n\r\n/**\r\n * üîê Create a short-lived temp token (email/phone verification)\r\n */\r\nexport function signTemp(payload: Record<string, any>, expiresIn: string = \"15m\"): string {\r\n  const safePayload = { ...payload };\r\n  delete safePayload.exp;\r\n  return jwt.sign(safePayload, SECRET!, { expiresIn });\r\n}\r\n\r\n/**\r\n * ‚úÖ Verify short-lived temp tokens\r\n * Returns payload object or null if invalid/expired\r\n */\r\nexport function verifyTemp(token: string): Record<string, any> | null {\r\n  try {\r\n    return jwt.verify(token, SECRET!) as Record<string, any>;\r\n  } catch (err) {\r\n    console.warn(\"[JWT] verifyTemp failed:\", (err as Error).message);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * üíæ Create a long-lived session token for logged-in users\r\n */\r\nexport function signSession(payload: Record<string, any>, expiresIn: string = \"7d\"): string {\r\n  const safePayload = { ...payload };\r\n  delete safePayload.exp;\r\n  return jwt.sign(safePayload, SECRET!, { expiresIn });\r\n}\r\n\r\n/**\r\n * üîé Verify a session token\r\n * Returns payload object or null if invalid/expired\r\n */\r\nexport function verifySession(token: string): Record<string, any> | null {\r\n  try {\r\n    return jwt.verify(token, SECRET!) as Record<string, any>;\r\n  } catch (err) {\r\n    console.warn(\"[JWT] verifySession failed:\", (err as Error).message);\r\n    return null;\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,iBAAiB;;;;;;;;;;;AACjB;;AAEA,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU;AACrC,IAAI,CAAC,QAAQ;IACX;;SAEO;QACL,QAAQ,IAAI,CAAC;IACf;AACF;AAKO,SAAS,SAAS,OAA4B,EAAE,YAAoB,KAAK;IAC9E,MAAM,cAAc;QAAE,GAAG,OAAO;IAAC;IACjC,OAAO,YAAY,GAAG;IACtB,OAAO,kJAAG,CAAC,IAAI,CAAC,aAAa,QAAS;QAAE;IAAU;AACpD;AAMO,SAAS,WAAW,KAAa;IACtC,IAAI;QACF,OAAO,kJAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAO,KAAK;QACZ,QAAQ,IAAI,CAAC,4BAA4B,AAAC,IAAc,OAAO;QAC/D,OAAO;IACT;AACF;AAKO,SAAS,YAAY,OAA4B,EAAE,YAAoB,IAAI;IAChF,MAAM,cAAc;QAAE,GAAG,OAAO;IAAC;IACjC,OAAO,YAAY,GAAG;IACtB,OAAO,kJAAG,CAAC,IAAI,CAAC,aAAa,QAAS;QAAE;IAAU;AACpD;AAMO,SAAS,cAAc,KAAa;IACzC,IAAI;QACF,OAAO,kJAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAO,KAAK;QACZ,QAAQ,IAAI,CAAC,+BAA+B,AAAC,IAAc,OAAO;QAClE,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 154, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/lib/auth.ts"],"sourcesContent":["// src/lib/auth.ts\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { verifySession } from \"@/lib/jwt\";\r\n\r\nexport type SessionUser = {\r\n  id: string;\r\n  email?: string | null;\r\n  role: string;\r\n  organizationId?: string | null;\r\n};\r\n\r\nexport async function getSessionUser(req: Request): Promise<SessionUser | null> {\r\n  try {\r\n    // 1Ô∏è‚É£ Prefer Authorization header: \"Bearer <token>\"\r\n    let token: string | null = null;\r\n    const authHeader = req.headers.get(\"authorization\");\r\n    if (authHeader?.startsWith(\"Bearer \")) {\r\n      token = authHeader.slice(\"Bearer \".length).trim();\r\n    }\r\n\r\n    // 2Ô∏è‚É£ Fallback to cookies\r\n    if (!token) {\r\n      const cookieHeader = req.headers.get(\"cookie\") || \"\";\r\n      const cookies: Record<string, string> = Object.fromEntries(\r\n        cookieHeader\r\n          .split(\";\")\r\n          .map(c => c.trim().split(\"=\"))\r\n          .map(([k, v]) => [decodeURIComponent(k), decodeURIComponent(v)])\r\n      );\r\n      token = cookies[\"session\"] || cookies[\"token\"] || null;\r\n    }\r\n\r\n    if (!token) return null;\r\n\r\n    // 3Ô∏è‚É£ Verify token safely\r\n    const payload = verifySession(token);\r\n    if (!payload?.id) return null;\r\n\r\n    // 4Ô∏è‚É£ Fetch user from DB\r\n    const user = await prisma.user.findUnique({ where: { id: payload.id } });\r\n    if (!user) return null;\r\n\r\n    return {\r\n      id: user.id,\r\n      email: user.email ?? null,\r\n      role: user.role,\r\n      organizationId: user.organizationId,\r\n    };\r\n  } catch (err: any) {\r\n    console.warn(\"[getSessionUser] error:\", err?.message || err);\r\n    return null;\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA,kBAAkB;;;;;AAClB;AACA;;;AASO,eAAe,eAAe,GAAY;IAC/C,IAAI;QACF,oDAAoD;QACpD,IAAI,QAAuB;QAC3B,MAAM,aAAa,IAAI,OAAO,CAAC,GAAG,CAAC;QACnC,IAAI,YAAY,WAAW,YAAY;YACrC,QAAQ,WAAW,KAAK,CAAC,UAAU,MAAM,EAAE,IAAI;QACjD;QAEA,0BAA0B;QAC1B,IAAI,CAAC,OAAO;YACV,MAAM,eAAe,IAAI,OAAO,CAAC,GAAG,CAAC,aAAa;YAClD,MAAM,UAAkC,OAAO,WAAW,CACxD,aACG,KAAK,CAAC,KACN,GAAG,CAAC,CAAA,IAAK,EAAE,IAAI,GAAG,KAAK,CAAC,MACxB,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,GAAK;oBAAC,mBAAmB;oBAAI,mBAAmB;iBAAG;YAEnE,QAAQ,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,QAAQ,IAAI;QACpD;QAEA,IAAI,CAAC,OAAO,OAAO;QAEnB,0BAA0B;QAC1B,MAAM,UAAU,IAAA,oIAAa,EAAC;QAC9B,IAAI,CAAC,SAAS,IAAI,OAAO;QAEzB,yBAAyB;QACzB,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE,IAAI,QAAQ,EAAE;YAAC;QAAE;QACtE,IAAI,CAAC,MAAM,OAAO;QAElB,OAAO;YACL,IAAI,KAAK,EAAE;YACX,OAAO,KAAK,KAAK,IAAI;YACrB,MAAM,KAAK,IAAI;YACf,gBAAgB,KAAK,cAAc;QACrC;IACF,EAAE,OAAO,KAAU;QACjB,QAAQ,IAAI,CAAC,2BAA2B,KAAK,WAAW;QACxD,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 206, "column": 0}, "map": {"version":3,"sources":["file:///E:/Attack%20Capital/SignalHub/frontend/src/app/api/me/route.ts"],"sourcesContent":["// src/app/api/me/route.ts\r\nimport { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { getSessionUser } from \"@/lib/auth\";\r\nimport { cookies } from \"next/headers\";\r\nimport jwt from \"jsonwebtoken\";\r\n\r\n/**\r\n * Note:\r\n * - This route attempts multiple ways to resolve the session:\r\n *   1) preferred: getSessionUser(req) (your existing helper)\r\n *   2) fallback: Authorization: Bearer <token> header\r\n *   3) fallback: read 'session' cookie server-side and verify JWT\r\n *\r\n * - GET responses include Cache-Control: no-store so server components\r\n *   fetching /api/me always get the latest session state (important).\r\n *\r\n * - If you use a different cookie name than 'session', change COOKIE_NAME.\r\n */\r\n\r\nconst COOKIE_NAME = \"session\";\r\nconst JWT_SECRET = process.env.JWT_SECRET || \"\";\r\n\r\nasync function jsonSafe(req: Request) {\r\n  try {\r\n    return await req.json();\r\n  } catch {\r\n    return {};\r\n  }\r\n}\r\n\r\n/**\r\n * Resolve a session user using multiple fallbacks.\r\n * Returns { id, name?, email? } or null.\r\n */\r\nasync function resolveSessionUser(req: Request) {\r\n  try {\r\n    // 1) primary helper (your existing logic)\r\n    try {\r\n      const s = await getSessionUser(req);\r\n      if (s) return s;\r\n    } catch (err) {\r\n      // don't fail hard here; fall through to other strategies\r\n      console.warn(\"getSessionUser failed:\", err);\r\n    }\r\n\r\n    // 2) try Authorization: Bearer <token>\r\n    try {\r\n      const authHeader = (req.headers.get(\"authorization\") ?? req.headers.get(\"Authorization\")) as string | null;\r\n      if (authHeader?.startsWith(\"Bearer \")) {\r\n        const token = authHeader.substring(7);\r\n        if (JWT_SECRET) {\r\n          const payload = jwt.verify(token, JWT_SECRET) as any;\r\n          if (payload?.id) return { id: payload.id, name: payload.name ?? null, email: payload.email ?? null };\r\n        }\r\n      }\r\n    } catch (err) {\r\n      // invalid bearer token ‚Äî ignore and continue\r\n      console.warn(\"Bearer token verification failed:\", err);\r\n    }\r\n\r\n    // 3) server-side cookie fallback\r\n    try {\r\n      const cookieStore = await cookies();\r\n      const token = cookieStore.get(COOKIE_NAME)?.value;\r\n      if (token && JWT_SECRET) {\r\n        const payload = jwt.verify(token, JWT_SECRET) as any;\r\n        if (payload?.id) return { id: payload.id, name: payload.name ?? null, email: payload.email ?? null };\r\n      }\r\n    } catch (err) {\r\n      console.warn(\"Cookie token verification failed:\", err);\r\n    }\r\n\r\n    return null;\r\n  } catch (err) {\r\n    console.error(\"resolveSessionUser unexpected error:\", err);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * GET /api/me\r\n */\r\nexport async function GET(req: Request) {\r\n  try {\r\n    const sessionUser = await resolveSessionUser(req);\r\n    if (!sessionUser) {\r\n      return NextResponse.json({ ok: false, user: null, error: \"Unauthorized\" }, { status: 401, headers: { \"Cache-Control\": \"no-store\" } });\r\n    }\r\n\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: sessionUser.id },\r\n      select: {\r\n        id: true,\r\n        name: true,\r\n        email: true,\r\n        phone: true,\r\n        role: true,\r\n        createdAt: true,\r\n        updatedAt: true,\r\n        profile: true,\r\n      },\r\n    });\r\n\r\n    if (!user) {\r\n      return NextResponse.json({ ok: false, user: null, error: \"User not found\" }, { status: 404, headers: { \"Cache-Control\": \"no-store\" } });\r\n    }\r\n\r\n    return NextResponse.json({ ok: true, user }, { status: 200, headers: { \"Cache-Control\": \"no-store\" } });\r\n  } catch (err) {\r\n    console.error(\"GET /api/me error:\", err);\r\n    return NextResponse.json({ ok: false, error: \"Internal server error\" }, { status: 500, headers: { \"Cache-Control\": \"no-store\" } });\r\n  }\r\n}\r\n\r\n/**\r\n * PATCH /api/me\r\n * - Upserts the user's profile and merges extensible metadata.\r\n */\r\nexport async function PATCH(req: Request) {\r\n  try {\r\n    const sessionUser = await resolveSessionUser(req);\r\n    if (!sessionUser) {\r\n      return NextResponse.json({ ok: false, error: \"Unauthorized\" }, { status: 401 });\r\n    }\r\n\r\n    const body = await jsonSafe(req);\r\n    console.log(\"PATCH /api/me payload:\", JSON.stringify(body));\r\n\r\n    // name is required as per original logic; you can relax this if desired\r\n    const name = typeof body.name === \"string\" ? body.name.trim() : undefined;\r\n    const phone = typeof body.phone === \"string\" ? body.phone.trim() : undefined;\r\n    const incomingProfile = typeof body.profile === \"object\" && body.profile ? body.profile : {};\r\n\r\n    if (!name || name.length === 0) {\r\n      return NextResponse.json({ ok: false, error: \"Name is required\" }, { status: 400 });\r\n    }\r\n\r\n    // simple length guards\r\n    if (typeof name === \"string\" && name.length > 200) {\r\n      return NextResponse.json({ ok: false, error: \"Name too long\" }, { status: 400 });\r\n    }\r\n    if (phone && phone.length > 40) {\r\n      return NextResponse.json({ ok: false, error: \"Phone too long\" }, { status: 400 });\r\n    }\r\n\r\n    // sanitize incoming profile fields\r\n    const profileUpdates: any = {\r\n      displayName: typeof incomingProfile.displayName === \"string\" ? incomingProfile.displayName.trim() : undefined,\r\n      avatarUrl: typeof incomingProfile.avatarUrl === \"string\" ? incomingProfile.avatarUrl.trim() : undefined,\r\n      bio: typeof incomingProfile.bio === \"string\" ? incomingProfile.bio.trim() : undefined,\r\n      phoneNumber: typeof incomingProfile.phoneNumber === \"string\" ? incomingProfile.phoneNumber.trim() : phone ?? undefined,\r\n    };\r\n\r\n    // Build metadata (extensible)\r\n    const metadata: Record<string, any> = {};\r\n    if (typeof incomingProfile.country === \"string\") metadata.country = incomingProfile.country;\r\n    if (typeof incomingProfile.region === \"string\") metadata.region = incomingProfile.region;\r\n    if (typeof incomingProfile.district === \"string\") metadata.district = incomingProfile.district;\r\n    if (typeof incomingProfile.postalCode === \"string\") metadata.postalCode = incomingProfile.postalCode;\r\n    if (typeof incomingProfile.language === \"string\") metadata.language = incomingProfile.language;\r\n\r\n    // fetch existing profile metadata and merge\r\n    const existingProfileRow = await prisma.profile.findUnique({\r\n      where: { userId: sessionUser.id },\r\n      select: { metadata: true },\r\n    });\r\n    const existingMetadata = (existingProfileRow?.metadata as any) ?? {};\r\n    const mergedMetadata = { ...existingMetadata, ...metadata };\r\n\r\n    // upsert profile via nested update on User\r\n    const updatedUser = await prisma.user.update({\r\n      where: { id: sessionUser.id },\r\n      data: {\r\n        name,\r\n        phone,\r\n        profile: {\r\n          upsert: {\r\n            create: {\r\n              displayName: profileUpdates.displayName ?? null,\r\n              avatarUrl: profileUpdates.avatarUrl ?? null,\r\n              bio: profileUpdates.bio ?? null,\r\n              phoneNumber: profileUpdates.phoneNumber ?? null,\r\n              metadata: mergedMetadata,\r\n            },\r\n            update: {\r\n              ...(profileUpdates.displayName !== undefined ? { displayName: profileUpdates.displayName } : {}),\r\n              ...(profileUpdates.avatarUrl !== undefined ? { avatarUrl: profileUpdates.avatarUrl } : {}),\r\n              ...(profileUpdates.bio !== undefined ? { bio: profileUpdates.bio } : {}),\r\n              ...(profileUpdates.phoneNumber !== undefined ? { phoneNumber: profileUpdates.phoneNumber } : {}),\r\n              metadata: mergedMetadata,\r\n            },\r\n          },\r\n        },\r\n      },\r\n      select: {\r\n        id: true,\r\n        name: true,\r\n        email: true,\r\n        phone: true,\r\n        role: true,\r\n        createdAt: true,\r\n        updatedAt: true,\r\n        profile: true,\r\n      },\r\n    });\r\n\r\n    console.log(\"PATCH /api/me updated user id:\", updatedUser.id);\r\n    return NextResponse.json({ ok: true, user: updatedUser }, { status: 200 });\r\n  } catch (err: any) {\r\n    console.error(\"PATCH /api/me error:\", err?.message ?? err, err?.stack ?? \"\");\r\n    if ((err as any).code) console.error(\"Prisma error code:\", (err as any).code, \"meta:\", (err as any).meta ?? null);\r\n    return NextResponse.json({ ok: false, error: \"Internal server error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}